<!DOCTYPE HTML>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>柳公子</title>
        <link rel="stylesheet" type="text/css" href="http://huliuqing.github.io/stylesheets/reset.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="http://huliuqing.github.io/stylesheets/layout.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="http://huliuqing.github.io/stylesheets/main.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="http://huliuqing.github.io/stylesheets/font.css" media="screen" />
        
        <script type="text/javascript" src="http://lib.sinaapp.com/js/jquery/1.9.0/jquery.min.js"></script>
        <link rel="stylesheet" type="text/css" href="http://imnerd.org/lab/pmblog/src/desert.css" />
        <script type="text/javascript" src="http://imnerd.org/lab/pmblog/src/prettify.js"></script>
        <link rel="stylesheet" href="http://fancyapps.com/fancybox/source/jquery.fancybox.css?v=2.1.4" type="text/css" media="screen" />
        <script type="text/javascript" src="http://fancyapps.com/fancybox/source/jquery.fancybox.pack.js?v=2.1.4"></script>
    </head>
    <body>
        <div class="wrapper">
            <div class="header">
                <div class="brand">
                    <a href="http://huliuqing.github.com" class="avatar">
                        <img src="http://huliuqing.github.io/images/header.jpg" alt="柳公子">
                    </a>    
                    <h1><a href="http://huliuqing.github.io">柳公子</a></h1>
                </div>

        
                <div class="menu">  
                    <h2>导航 / menu</h2>              
                    <ul>        
                                                    <li><a href="http://huliuqing.github.io/index.html "  title="首页">首页</a></li>
                                                    <li><a href="http://huliuqing.github.io/contactme.html "  title="联系柳公子">联系我</a></li>
                                                    <li><a href="http://huliuqing.github.io/aboutme.html "  title="关于柳公子">关于我</a></li>
                            
                    </ul>
                </div>
                <div class="search">
                    <form>
                        <input type="text" name="search" id="search" value="" placeholder="搜索"></input>
                        <button id="sbutton">搜索</button>
                    </form>
                </div>  
            </div><!--end / header -->

            <div class="contents">    				<div class="sider">

												
					<div class="links">		
						<h2>友链 / friend links</h2>
						<ul>
					        					        	<li><a href="http://stackoverflow.com/users/1969039/liuqing-hu"  title="柳公子在stackoverflow">stackoverflow</a></li>
					        					        	<li><a href="https://github.com/huliuqing"  title="柳公子在github">github</a></li>
					        					        	<li><a href="http://huliuqing.diandian.com "  title="柳公子在点点博客">柳公子 - 点点网</a></li>
					        					        	<li><a href="http://weibo.com/focusliuqing"  title="柳公子在新浪微博">柳公子 - weibo</a></li>
					              
						</ul>
					</div>			
					
					<div class="links">
						<h2>找到我/find me</h2>		
						<ul>
					        <li><a href="http://huliuqing.diandian.com">柳公子点点博客</a></li>    
					        <li><a href=" http://stackoverflow.com/users/1969039/liuqing-hu">柳公子StackOverflow</a></li>
					        <li><a href="https://github.com/huliuqing">柳公子github</a></li>
						</ul>
					</div>
				</div><!--end/left sider-->                <div class="posts">
                                            <div class="post">
                            <h2><a href="http://huliuqing.github.io/2014-05-29-how-to-write-a-bat-file.html">如何创建简单的批处理（.bat）文件[译文]</a></h2>
                            <div class="post-content"><blockquote>
    如未特别标明，文章均属原创。转载请注明出处 
    
by : 柳公子 <a href="http://huliuqing.github.io">http://huliuqing.github.io</a>
</blockquote>

<p>想简单的学习批处理文件书写方法，于是翻译了这篇文章。原文<a href="http://www.makeuseof.com/tag/write-simple-batch-bat-file/">在这</a></p>

<h2>1.创建一个.bat文件</h2>

<p>在桌面创建一个文本文件，打开刚刚创建的文件。点解 file > save as，并输入批处理文件的文件名以.bat结尾。我创建的是testbat.bat</p>

<h2>2.快速掌握基本关键字</h2>

<p>如果你会使用命令行模式，那你更容易使用批处理文件,因为批处理文件和命令行模式使用同一种语言。我们仅仅需要通过批处理文件告诉命令行提示符需要做什么，而不是每次都打开命令行输入那些命令。这会为我们节省大量时间。只不过我们需要在批处理文件中添加一些逻辑处理（如简单的循环，条件语句等）</p>

<p>有如下7个简单的命令我们需要去熟悉，在命令行模式下这些命令是不区分大小写的</p>

<pre><code>TITLE - 设置命令提示窗口的窗口标题。默认为“cmd”

ECHO  - 批文件的输出语句。echo之后的所有词语都会在命令行中显示出来

ECHO OFF - 通常放在文件第一行。告诉命令行不要显示bat文件中的命令

PAUSE - 使用此关键字将会在命令行中输出“press any key to continue”,这样我们就可以有更多的时间去查看命令信息。这条语句在调试的时候会非常有用，因为它会终止批文件继续执行除非我们按下任意键。

CLS   - 清屏处理

IPCONFIG 打印输出当前的TCP/IP配置的设置值

ping     ping + ip地址，让我们知道电脑是否正常通讯
</code></pre>

<h2>3.快速掌握逻辑语句</h2>

<p>问题
  ① 通过ipconfig/all检测电脑网络设置
  ② 预留时间给用户阅读信息
  ③ ping google.com以检测我们的电脑是否联网了
  ④ 预留时间给用户阅读信息</p>

<h2>4.编写.bat文件</h2>

<pre><code>echo off    
chcp 65001
echo 通过bat文件，执行查看网络连接是否正常
ipconfig /all
pause
ping www.google.com
echo 所有执行通过
pause
</code></pre>

<h2>5.点击.bat文件运行</h2>
</div>
                            <span class="post-date">2014-05-29 09:00:00</span>
                            <span class="post-tag">批处理, 教程</span>
                        </div>
                                            <div class="post">
                            <h2><a href="http://huliuqing.github.io/2014-05-27-install-memcache-in-php.html">memcache缓存处理简介</a></h2>
                            <div class="post-content"><blockquote>
  <p>如未特别标明，文章均属原创。转载请注明出处。by : 柳公子 <a href="http://huliuqing.github.io">http://huliuqing.github.io</a></p>
</blockquote>

<p>进行PHP开发工作3年，直到最近才更专注的去思考关于PHP项目性能问题（一直以来有去了解，但并未深入的去学习）。这篇文章简单讲解在windows平台下PHP开发中，安装和使用memcached缓存系统。</p>

<p>先来看看维基百科关于<a href="http://zh.wikipedia.org/wiki/Memcached" target="_blank">memcached</a>的解释：</p>

<blockquote>
  <p>memcached是一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发，但目前被许多网站使用。这是一套开放源代码软件，以BSD license授权发布。
  ...
  memcached的API使用三十二比特的循环冗余校验（CRC-32）计算键值后，将数据分散在不同的机器上。当表格满了以后，接下来新增的数据会以LRU机制替换掉。由于memcached通常只是当作高速缓存系统使用，所以使用memcached的应用程序在写回较慢的系统时（像是后端的数据库）需要额外的代码更新memcached内的数据。</p>
</blockquote>

<p>感觉很高端的样子，简单来说<code>memcached</code>是一套分布式的内存对象缓存系统，<code>Key/Value</code>值对以Hashmap方式缓存到内存中，以降低Web应用对数据库、文件读取的压力。</p>

<h2>memcached缓存系统组成</h2>

<p>一）  memcached服务守护程序</p>

<p>服务器守护程序是用C编写的，为客户端程序提供服务。<a href="http://code.jellycan.com/files/memcached-1.2.6-win32-bin.zip">点这里下载</a></p>

<p>二）  memcache客户端程序</p>

<p>客户端程序可以是任意语言编写的，通过memcached协议与守护程序通信。我们这下载PHP开发相关的版本。<a href="http://downloads.php.net/pierre/" target="_blank">到这里去下载</a></p>

<h2>memcached服务守护程序安装</h2>

<ol>
<li><p>1.下载memcached服务器程序,获取memcached.exe文件。<a href="http://code.jellycan.com/files/memcached-1.2.6-win32-bin.zip">点这里下载</a></p></li>
<li><p>2.进入命令行模式，使用命令安装memcached
c:/memcached/memcached.exe -d install</p></li>
<li><p>3.启动服务
c:/memcached/memcached.exe -d start</p></li>
</ol>

<p>默认情况下memcached服务器程序监听<code>11211</code>端口,并指定缓存使用的最大内存为<code>64MB</code>。</p>

<p>常用memcached选项参数</p>

<pre><code>-m 指定缓存所使用的最大内存容量，单位是Megabytes，默认是64MB
-u 只有以root身份运行时才指定该参数
-d 以daemon的形式运行
-l 指定监听的地址
-p 指定监听的TCP端口号，默认是11211

//"-d"参数更多选项值
-d install 安装memcached
-d uninstall 卸载memcached
-d start 启动memcached服务
-d restart 重启memcached服务
-d stop 停止memcached服务
-d shutdown 停止memcached服务
</code></pre>

<p>更多memcached选项参数，<a href="http://works.jinbuguo.com/man/memcached.html">点这里去了解</a></p>

<h2>memcache客户端安装</h2>

<p>如果使用XAMPP/WAMP集成开发环境，我们仅需下载php_memcache扩展程序。</p>

<ol>
<li><p>1.下载dll扩展程序（<a href="http://downloads.php.net/pierre/" target="_blank">到这里去下载</a>）,放于c:/xampp/php/ext/目录下。</p></li>
<li><p>2.开启扩展服务。
进入php.ini文件添加如下<code>extension=php_memcache.dll</code></p></li>
<li><p>3.重新启动XAMPP/WAMP</p></li>
</ol>

<h2>使用memcache缓存</h2>

<p>超简单示例：</p>

<pre><code>&lt;?php
$memcache = new Memcache;

$memcache-&gt;connect('127.0.0.1',11211);
$memcache-&gt;add('name','柳公子');
$name = $memcache-&gt;get('name');

echo $name;
</code></pre>

<p>进入官网手册，了解更多关于<a href="http://cn2.php.net/manual/zh/book.memcache.php">memcache</a>相关信息</p>

<h2>工具</h2>

<p><a href="http://www.junopen.com/memadmin/" target="_blank">memcache监控程序</a></p>

<p>参考资料：</p>

<p><a href="http://works.jinbuguo.com/man/memcached.html">memcache手册中文</a></p>

<p><a href="http://www.codeforest.net/how-to-install-memcached-on-windows-machine">How to install Memcached on Windows machine</a></p>

<p><a href="http://blog.csdn.net/poechant/article/details/7074257">Memcached基础及示例程序</a></p>

<p><a href="http://blog.csdn.net/poechant/article/details/7082115">Memcached配置参数初解</a></p>

<p><a href="http://zh.wikipedia.org/wiki/Memcached">维基百科：memcached</a></p>

<p><a href="http://baike.baidu.com/view/794242.htm">百度百科：memcached</a></p>

<p><a href="http://cn2.php.net/manual/zh/book.memcache.php">手册：memcached</a></p>
</div>
                            <span class="post-date">2014-05-27 17:55:00</span>
                            <span class="post-tag">php, 缓存技术, memcache</span>
                        </div>
                                            <div class="post">
                            <h2><a href="http://huliuqing.github.io/2014-05-26-translate-PHP-website-optimization.html">如何优化PHP网站[译]</a></h2>
                            <div class="post-content"><p>转载请注明出处</p>

<p>这是一篇翻译自stackOverflow的文章，由于水平有限难免出错，如果您在阅读的时候发现了，请帮我更正。</p>

<h2>如何优化PHP网站</h2>

<p>问题如下（原文：<a href="http://stackoverflow.com/questions/8258567/php-website-optimization/8259911#8259911">PHP website Optimization</a>）：
    我拥有一个高访问量的网站，需要保证每个访问我站点的用户，都能够在最短的时间内显示出他们请求的页面。
    我通过Google搜索大量关于网站访问速度和优化方法的文章，并得出如下几个方案：</p>

<pre><code>    1. 对页面缓存
        通过对页面缓存，我可以让访问更加快速。但是如果我变更了页面的内容，我则必须把页面的内容从缓存中删除并重新对文件进行缓存。
    2. 页面静态化（把页面保存在磁盘中）
        通过页面静态化，我可以比较简单的对它进行维护。只是这样的话我必须每次访问它所在的目录来进行维护工作。
</code></pre>

<p>那么究竟如何才能够达到我想要的目的呢？</p>

<h2>------------------------------------------------------------------------------------------</h2>

<h2>来自Book Of Zeus的回答:</h2>

<p><a href="http://stackoverflow.com/a/8259911/3675700">Book Of Zeus</a></p>

<p>对于网站的性能来说，当我们需要获取静态或动态的内容时，减少访问数据库或文件系统的请求数，启用缓存（缓存页面或部分内容）是很重要的一个环节。</p>

<p>在运行动态内容的时候，我们可以使用加速PHP处理的软件：</p>

<p>（一）在这我推荐使用Alternative PHP Cache(<a href="http://php.net/manual/en/book.apc.php">通过手册了解更多关于APC信息</a>)。</p>

<p>推荐几篇关于APC的好文章给你：</p>

<ol>
<li><p>1.<a href="http://agilewebmasters.com/robert/what-is-the-best-php-accelerator-to-use/">What is the best PHP accelerator to use?
</a></p></li>
<li><p>2.<a href="http://blog.digitalstruct.com/2007/12/23/php-accelerators-apc-vs-zend-vs-xcache-with-zend-framework/">PHP Accelerators : APC vs Zend vs XCache with Zend Framework</a></p></li>
<li><p>3.<a href="http://blog.bodhizazen.net/linux/lighttpd-php-acceleration-benchmarks/">Lighttpd – PHP Acceleration Benchmarks</a></p></li>
</ol>

<p>（二）如果是缓存内容或整个页面的话，最好使用<a href="http://memcached.org">Memcached</a> 或 <a href="http://redis.io">Redis</a>进行缓存。</p>

<ol>
<li><p>1.<code>memcached</code>
一个高性能的分布式内存对象缓存开源系统。用于降低数据库负载，提升动态web程序的访问速度。memcached是通过把从数据库中返回的结果集、调用API返回的结果集或者呈现的页面。在内存中以键值对的形式进行缓存。</p></li>
<li><p>2.<code>Redis</code>
一款高性能键值对存储数据库开源项目。当值为字符，哈希表，列表，集合或排序集合时，它被视作一种数据结构服务程序。</p></li>
</ol>

<p>这两个(Memcached和Redis)项目都是用于缓存内容和变量的绝好工具。</p>

<p>推荐几篇有关Memcached和Redis的相关文章：</p>

<ol>
<li><p>1.<a href="http://trespams.com/2011/08/05/redis-vs-memcached-en/">Redis vs Memcached</a></p></li>
<li><p>2.<a href="On Redis, Memcached, Speed, Benchmarks and The Toilet">On Redis, Memcached, Speed, Benchmarks and The Toilet</a></p></li>
<li><p>3.<a href="http://systoilet.wordpress.com/2010/08/09/redis-vs-memcached/">Redis vs Memcached</a></p></li>
<li><p>4.<a href="http://dormando.livejournal.com/525147.html">Redis VS Memcached (slightly better bench)</a></p></li>
</ol>

<p>（三）使用varnish，nginx或G-Wan</p>

<ol>
<li><p>1.<code>Varnish</code>
一款专为有大量动态内容web网站设计的HTTP加速器。与其它HTTP加速器相比，如squid在客户端缓存;Apache则仅仅是服务器软件。Varnish则一开始就被设计成为HTTP加速器。</p></li>
<li><p>2.<code>Nginx</code>
是一款由俄罗斯程序员Igor Sysoev所开发轻量级的网页服务器、反向代理服务器以及电子邮件（IMAP/POP3）代理服务器。起初是供俄国大型的门户网站及搜索引擎Rambler（俄语：Рамблер）使用。此软件BSD-like协议下发行，可以在UNIX、GNU/Linux、BSD、Mac OS X、Solaris，以及Microsoft Windows等操作系统中运行</p></li>
<li><p>3.<code>g-wan</code>
C编写的Web服务器，比其它采用键值对存储的解决方案更加快速</p></li>
</ol>

<p>一些文章：   </p>

<ol>
<li><p>1.<a href="http://nbonvin.wordpress.com/2011/03/14/apache-vs-nginx-vs-varnish-vs-gwan/">Serving static files: a comparison between Apache, Nginx, Varnish and G-WAN</a></p></li>
<li><p>2.<a href="http://loadstorm.com/2011/05/web-server-performance-benchmarks/">Web Server Performance Benchmarks</a></p></li>
<li><p>3.<a href="http://www.garron.me/en/go2linux/nginx-varnish-vs-nginx-alone-compared.html">Nginx+Varnish compared to Nginx</a></p></li>
<li><p>4.<a href="http://cd34.com/blog/infrastructure/apache-varnish-nginx-and-lighttpd/">Apache, Varnish, nginx and lighttpd</a></p></li>
<li><p>5.<a href="http://www.wikivs.com/wiki/G-WAN_vs_Nginx">G-WAN vs Nginx</a></p></li>
</ol>

<p>(to be continued)</p>
</div>
                            <span class="post-date">2014-05-26 18:00:00</span>
                            <span class="post-tag">php, Web, 优化, PHP优化</span>
                        </div>
                                            <div class="post">
                            <h2><a href="http://huliuqing.github.io/2014-05-26-introduce-php-test-tool-ab.html">Apache Bench 工具介绍</a></h2>
                            <div class="post-content"><blockquote>
  <p>如未特别标明，文章均属原创。转载请注明出处 
      by : 柳公子 <a href="http://huliuqing.github.io ">http://huliuqing.github.io </a></p>
</blockquote>

<p>apache benchmark（以下简称ab）是一款基准测试工具,用于描绘当前安装的apache服务器的执行性能,是apache安装的一部分。用户可以模拟对特定URL的任意数量请求来对Web服务器进行负载测试，观察你的apache服务器每秒可以处理多少请求。</p>

<p>ab工具提供以下信息：</p>

<ul>
<li>传输的总大小</li>
<li>Web服务器在模拟流量下每秒可以支持的请求总数</li>
<li>完成一个请求所花费的最长时间</li>
<li>完成一个请求所花费的最少时间</li>
</ul>

<h2>ab语法</h2>

<pre><code>ab
    [-A auth-username:password]
    [-c concurrency]
    [-C cookie-name=value]
    [-d]
    [-e csv-file]
    [-g gnuplot-file]
    [-h]
    [-H custom-header]
    [-i]
    [-k]
    [-n requests]
    [-p POST-file]
    [-P proxy-auth-username:password]
    [-q]
    [-s]
    [-S]
    [-t timelimit]
    [-T content-type]
    [-v verbosity]
    [-V]
    [-w]
    [-x &lt;table&gt;-attributes]
    [-X proxy[:port]]
    [-y &lt;tr&gt;-attributes]
    [-z &lt;td&gt;-attributes]
[http://]hostname[:port]/path
</code></pre>

<h2>ab选项标记</h2>

<pre><code>-A auth-username:password 
向服务器提供基本认证信息。用户名和密码之间由一个":"隔开，并将被以base64编码形式发送。无论
服务器是否需要(即是否发送了401认证需求代码)，此字符串都会被发送。 

-c concurrency 
一次产生的请求个数。默认设置为1。 

-C cookie-name=value 
对请求附加一个"Cookie:"头行。其典型形式是 name=value 的一个参数对。此参数可以重复。

-d 
不显示"percentage served within XX [ms] table"消息(为以前的版本提供支持)。 

-e csv-file 
产生一个逗号分隔(CSV)文件，该文件包含基准测试的运行结果(其中包含了处理每个相应
百分比[Percentage served]请求(从1%到100%)所需要的相应百分比时间[Time in ms](以微
秒为单位))。由于这种格式已经"二进制化"，所以比"gnuplot"格式更有用。 

-g gnuplot-file 
把所有测试结果写入一个"gnuplot"或者TSV(以Tab分隔)文件。此文件可以方便地导入到 Gnuplot,
IDL, Mathematica, Excel中。其中的第一行为标题。 

-h 
显示要用于ab的选项列表。 

-H custom-header 
对请求附加额外的头信息。此参数的典型形式是一个有效的头信息行，其中包含了以冒号分隔的字段
和值(如："Accept-Encoding: zip/zop;8bit")。 

-i 
执行HEAD请求，而不是默认的GET请求 。 

-k 
启用KeepAlive功能，即在一个HTTP会话中执行多个请求。默认不启用KeepAlive功能。 

-n requests 
在测试会话中所执行的请求个数。默认仅执行一个请求，此时其结果不具有意义，n值最大为50000。

-p POST-file 
包含了POST数据的文件。 

-P proxy-auth-username:password 
对一个中转代理提供基本认证信息。用户名和密码由一个":"隔开，并将被以base64编码形式发送。
无论服务器是否需要(即是否发送了407代理认证需求代码)，此字符串都会被发送。 

-q 
如果处理的请求数大于150，ab每处理大约10%或者100个请求时，会在stderr输出一个进度计数。此 
-q 标记可以屏蔽这些信息。

-s 
用于编译中(ab -h 会告诉你)使用了SSL的受保护的https ，而不是http协议的时候。此功能是实验性的，最好不要用。 

-S 
不显示中值和标准偏差值，而且在均值和中值为标准偏差值的1到2倍时，也不显示警告或出错信息。
默认时，会显示最小值/均值/最大值等数值。(为以前的版本提供支持) 

-t timelimit 
测试所进行的最大秒数。内部隐含值是"-n 50000"。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。

-T content-type 
POST数据时所使用的"Content-type"头信息。 

-v verbosity 
设置显示信息的详细程度，4或更大值会显示头信息，3或更大值可以显示响应代码(404，200等)，2或更大值可以显示警告和其他信息。 

-V 
显示版本号并退出。 

-w 
以HTML表格形式输出结果。默认时，它是白色背景的两列宽度的一张表。 

-x &lt;table&gt;-attributes 
设置&lt;table&gt;属性的字符串。此属性被填入&lt;table 这里 &gt; 。 

-X proxy[:port] 
对请求使用代理服务器。 

-y &lt;tr&gt;-attributes 
设置&lt;tr&gt;属性的字符串。 

-z &lt;td&gt;-attributes 
设置&lt;td&gt;属性的字符串。 
</code></pre>

<h2>运行ab工具</h2>

<p>现在我们要运行ab工具来对http://www.github.com来进行基准测试。
运行如下命令：</p>

<p>ab -n 1 http://www.github.com/</p>

<p>输出结果如下</p>

<pre><code>Server Software:
Server Hostname:        www.github.com
Server Port:            80
#服务器信息


Document Path:          /
Document Length:        0 bytes
#文档信息


Concurrency Level:      1
Time taken for tests:   1.651 seconds
Complete requests:      1
Failed requests:        0
Write errors:           0
Non-2xx responses:      1
Total transferred:      107 bytes
HTML transferred:       0 bytes
Requests per second:    0.61 [#/sec] (mean)
Time per request:       1650.709 [ms] (mean)
Time per request:       1650.709 [ms] (mean, across all concurrent requests)
Transfer rate:          0.06 [Kbytes/sec] received
#连接信息


Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:      862  862   0.0    862     862
Processing:   788  788   0.0    788     788
Waiting:      788  788   0.0    788     788
Total:       1650 1650   0.0   1650    1650
#连接指标分类
</code></pre>

<h2>1. 服务器信息部分</h2>

<p>一般我们的Web服务器软件会是apache，那么在Server Software : 中会显示 apache : 。
但是由于Web管理员使用安全措施，该字段可能返回其它内容或什么也不返回（如示例）</p>

<pre><code>Server Hostname : 测试主机名
Server Post : 测试主机的Web服务器监听端口号
</code></pre>

<h2>2. 脚本信息部分</h2>

<p>包含基准测试主机的Web文档的信息内容</p>

<pre><code>Document Path :  包含测试请求的文档
Document Length : 包含所有HTML 、CSS、JS、图像及其响应的其它数据的字节数总和
</code></pre>

<h2>3. 链接信息部分</h2>

<p>连接数据包含基准测试信息最核心的反馈信息。
其中最需要关心的内容部分：</p>

<pre><code>    HTML transferred    整个模拟测试中传输的内容正文总大小
    Requests per second 每秒支持的请求数
    Time per request    满足一个请求需要花费的总时间
</code></pre>

<p>优化目标：减少HTML transferred 大小，提高Requests per second并降低Time per request值</p>

<h2>4. 连接指标分类</h2>

<p>在这一部分我们主要关注Total项目中的min : ,max : 列</p>

<pre><code>min : 请求所花费的最短时间
man : 请求所花费的最长时间
</code></pre>

<h2>参考资料</h2>

<p><a href="http://apache.chinahtml.com/programs/ab.html">apache 中文手册</a> </p>

<p>未完待续</p>
</div>
                            <span class="post-date">2014-05-26 14:51:52</span>
                            <span class="post-tag">php, apache, 压力测试, 工具</span>
                        </div>
                                            <div class="post">
                            <h2><a href="http://huliuqing.github.io/2014-05-15-analyze-object-iterator-in-php.html">详解PHP中对象属性遍历</a></h2>
                            <div class="post-content"><h2>对象迭代</h2>

<p><blockquote>
    如未特别标明，文章均属原创。转载请注明出处 </p>

<p>by : 柳公子 <a href="http://huliuqing.github.io">http://huliuqing.github.io</a>
</blockquote></p>

<p>php官网手册对于<a href="http://www.php.net/manual/zh/language.oop5.iterations.php" target="_blank">遍历对象</a>解释如下：
<blockquote>PHP 5 提供了一种定义对象的方法使其可以通过单元列表来遍历，例如用 foreach 语句。默认情况下，所有可见属性都将被用于遍历。 </blockquote></p>

<p>不过使用简单的foreach遍历对象，仅仅能够遍历出对象实例中可见（public)属性的值。</p>

<p>foreach是如何实现对对象进行遍历的呢？</p>

<p>我们的鸟哥在<a href="http://www.laruence.com/2008/10/31/574.html" >关于一笔试题(Iterator模式) </a>一文中分享过foreach源码实现。这边我就拿来主义了：</p>

<pre><code>switch (zend_iterator_unwrap(array, &amp;iter TSRMLS_CC)) {
    default:
        case ZEND_ITER_INVALID:
               .....
               break
        case ZEND_ITER_PLAIN_OBJECT: {
                ......
            break;
     case ZEND_ITER_PLAIN_ARRAY:
            .....
            break;

        case ZEND_ITER_OBJECT:
            ......
            break;
}
</code></pre>

<p>具体如何使用<code>foreach</code>遍历对象，查看示例：</p>

<pre><code>&lt;?php

class Student{
    private $_identityCard = '360401190001011018';
    public  $_name = '三丰';
    public  $_age  = 800;

    protected $_bloodType = 'O';

    public function __construct(){}
}

$s = new Student();

foreach($s as $key =&gt; $v){
    echo 'key ',$key ,' val ',$v ,'&lt;/br&gt;';
}

//输出
key :_name val 三丰
key :_age val 800
</code></pre>

<p>从输出的结果来看，实例化对象的所有可见(<code>public</code>)属性都给遍历输出出来了。</p>

<p>但是，当我们需要遍历那些非可见对象属性，明显简单的使用<code>foreach</code>遍历对象就不够用了。</p>

<p>好在PHP中有提供内置遍历接口<code>Iterator</code> 和 <code>IteratorAggregate</code>完成对象的遍历工作。
关于Iterator与IteratorAggregate接口如下：</p>

<pre><code>Iterator extends Traversable {
    /* 方法 */
    abstract public mixed current ( void )//返回当前元素。 
    abstract public scalar key ( void )   //返回当前元素的键
    abstract public void next ( void )    //移动当前位置到下一个元素
    abstract public void rewind ( void )  //返回到迭代器的第一个元素
    abstract public boolean valid ( void )//此方法在 Iterator::rewind() 和 Iterator::next()
                                          //方法之后被调用以此用来检查当前位置是否有效
}

IteratorAggregate extends Traversable {
    /* 方法 */
    abstract public Traversable getIterator ( void )//返回一个外部迭代器
}
</code></pre>

<p>我们可以通过实现这两个迭代器接口，定义自己的对象遍历规则</p>

<p>1、通过实现IteratorAggregate接口，完成对象属性遍历</p>

<p>我们只需要实现IteratorAggregate中getIterator()方法完成遍历。</p>

<pre><code>class Kungfu implements IteratorAggregate{
    public $_name='飞鸿';
    public $_age = 121;

    protected $_bloodType = 'O';
    private $_isMarried = true;

    public function __construct(){}

    public function getIterator(){
        $members = get_class_vars(__CLASS__);

        return new ArrayIterator($members);
    }
}


$k = new Kungfu();

foreach($k as $key =&gt; $v){
    echo 'key ',$key ,' val ',$v ,'&lt;/br&gt;';
}
/*
    key _name val 飞鸿
    key _age val 121
    key _bloodType val O
    key _isMarried val 1
*/
</code></pre>

<p>2、通过实现Iterator接口，完成对象属性遍历</p>

<p>相对于<code>IteratorAggregate</code>而言，<code>Iterator</code>接口实现起来稍微麻烦一些，需要在实现类中实现所有5个抽象方法。</p>

<p>不过如果我们需要对迭代的对象，进行具体控制的话，使用<code>Iterator</code>的话则更合适。</p>

<pre><code>class Language implements Iterator{
    private $_lang;
    private $_counter=0;

    public function __construct(){      
        $this-&gt;_lang = explode(',', 'PHP,C++,C,GO,JAVA,JAVASCRIPT,RUBY,Node.js');
    }

    public function rewind(){
        $this-&gt;_counter = 0;
    }

    public function current(){
        //当编程语言的值为JAVA时，返回空
        if($this-&gt;_lang[$this-&gt;_counter] == 'JAVA'){
            return null;
        }
        return $this-&gt;_lang[$this-&gt;_counter];
    }

    public function valid(){
        return isset( $this-&gt;_lang[$this-&gt;_counter]);
    }

    public function next(){
        ++$this-&gt;_counter;
    }
    public function key(){
        return $this-&gt;_counter;
    }
}

$m = new Language();

foreach($m as $key =&gt; $v){
    echo 'key ',$key ,' val ',$v ,'&lt;/br&gt;';
}

//结果输出
key 0 val PHP
key 1 val C++
key 2 val C
key 3 val GO
key 4 val 
key 5 val JAVASCRIPT
key 6 val RUBY
key 7 val Node.js
</code></pre>

<p>接口<code>Iterator</code>中抽象方法的执行顺序如下图所示：
<img src="http://huliuqing.github.io/images/post-source/2014-05-analyze-object-iterator-in-php.png" title="Iterator抽象方法调用顺序"></img></p>
</div>
                            <span class="post-date">2014-05-15 10:41:30</span>
                            <span class="post-tag">php, 对象, 遍历, Iterator, Object</span>
                        </div>
                    
                    <div class="pagination">
                        <ul>
                                                            <li><a class="round pre" id="pre" href="http://huliuqing.github.io/page/1">1</a></li>
                            
                                                           <li> <a class="round next" id="next" href="http://huliuqing.github.io/page/3">3</a></li>
                                                    </ul>
                    </div>
                </div><!--end/posts-->

			</div><!--end /contents-->

			<div class="footer">
				<div class="social span3">
					<h3>关注我</h3>
					<ul>
						<li><a class="glyph" href="" title=""><i class="icon-weibo"></i></a></li>
						<li><a class="glyph" href="" title="点点网博客"> 点点网</a></li>
						<li><a class="glyph" href="" title="柳公子的gmail邮箱"> stackoverflow</a></li>
					</ul>
				</div>				
				<div class="list span3">
					<h3>我的博客</h3>
					<ul>
			        	<li><a href="http://stackoverflow.com/users/1969039/liuqing-hu" title="柳公子在stackoverflow">stackoverflow</a></li>
			        	<li><a href="https://github.com/huliuqing" title="柳公子在github" >github</a></li>
			        	<li><a href="http://huliuqing.diandian.com" title="柳公子在点点博客">柳公子 - 点点网</a></li>
			        	<li><a href="http://weibo.com/focusliuqing" title="柳公子在新浪微博">柳公子 - weibo</a></li>
					              
					</ul>
				</div>	

				<div class="list span3">
					<h3>主题</h3>
					<ul>
						<li>社交图标 by <a href="https://github.com/lexrus/fontdiao" title="fontdiao"> fontdiao</a></li>
						<li>主题 by <a href="https://huliuqing.github.io" title="柳公子">柳公子</a></li>
					</ul>
				</div>
			</div><!--end/footer-->
		</div><!--end/wrapper-->
	</body>	
	
	<script type="text/javascript">
	var s=document.getElementById('search'), b=document.getElementById('sbutton');
	b.onclick = function() {
		if(s.value != '') {
			window.open("https://www.google.com.hk/#q=site:http://huliuqing.github.io "+s.value);
		} else {
			alert('请输入搜索内容');
		}
	}	
	</script>
	
	<script type="text/javascript">
	$(function () {
		$("pre").addClass("prettyprint linenums");
		prettyPrint();
	})
	</script>

</html>