<!DOCTYPE HTML>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <title>柳公子</title>
            <link rel="stylesheet" type="text/css" href="http://huliuqing.github.io/stylesheets/reset.css" media="screen" />
            <link rel="stylesheet" type="text/css" href="http://huliuqing.github.io/stylesheets/layout.css" media="screen" />
            <link rel="stylesheet" type="text/css" href="http://huliuqing.github.io/stylesheets/main.css" media="screen" />
            <link rel="stylesheet" type="text/css" href="http://huliuqing.github.io/stylesheets/font.css" media="screen" />
            
            <script type="text/javascript" src="http://lib.sinaapp.com/js/jquery/1.9.0/jquery.min.js"></script>
            <link rel="stylesheet" type="text/css" href="http://imnerd.org/lab/pmblog/src/desert.css" />
            <script type="text/javascript" src="http://imnerd.org/lab/pmblog/src/prettify.js"></script>
            <link rel="stylesheet" href="http://fancyapps.com/fancybox/source/jquery.fancybox.css?v=2.1.4" type="text/css" media="screen" />
            <script type="text/javascript" src="http://fancyapps.com/fancybox/source/jquery.fancybox.pack.js?v=2.1.4"></script>
    </head>
    <body>
        <div class="wrapper">
            <div class="header">
                <div class="brand">
                    <a href="http://huliuqing.github.com" class="avatar">
                        <img src="http://huliuqing.github.io/images/header.jpg" alt="柳公子">
                    </a>    
                    <h1><a href="http://huliuqing.github.io">柳公子</a></h1>
                </div>

        
                <div class="menu">  
                    <h2>导航 / menu</h2>              
                    <ul>        
                                                    <li><a href="http://huliuqing.github.io/index.html "  title="首页">首页</a></li>
                                                    <li><a href="http://huliuqing.github.io/contactme.html "  title="联系柳公子">联系我</a></li>
                                                    <li><a href="http://huliuqing.github.io/aboutme.html "  title="关于柳公子">关于我</a></li>
                            
                    </ul>
                </div>
                <div class="search">
                    <form>
                        <input type="text" name="search" id="search" value="" placeholder="搜索"></input>
                        <button id="sbutton">搜索</button>
                    </form>
                </div>  
            </div><!--end / header -->

            <div class="contents">    				<div class="sider">

												
					<div class="links">		
						<h2>友链 / friend links</h2>
						<ul>
					        					        	<li><a href="http://stackoverflow.com/users/1969039/liuqing-hu"  title="柳公子在stackoverflow">stackoverflow</a></li>
					        					        	<li><a href="https://github.com/huliuqing"  title="柳公子在github">github</a></li>
					        					        	<li><a href="http://huliuqing.diandian.com "  title="柳公子在点点博客">柳公子 - 点点网</a></li>
					        					        	<li><a href="http://weibo.com/focusliuqing"  title="柳公子在新浪微博">柳公子 - weibo</a></li>
					              
						</ul>
					</div>			
					
					<div class="links">
						<h2>找到我/find me</h2>		
						<ul>
					        <li><a href="http://huliuqing.diandian.com">柳公子点点博客</a></li>    
					        <li><a href=" http://stackoverflow.com/users/1969039/liuqing-hu">柳公子StackOverflow</a></li>
					        <li><a href="https://github.com/huliuqing">柳公子github</a></li>
						</ul>
					</div>
				</div><!--end/left sider-->                <div class="posts">
                                            <div class="post">
                            <h2><a href="http://huliuqing.github.io/2014-05-27-install-memcache-in-php.html">memcache缓存处理简介</a></h2>
                            <div class="post-content"><blockquote>
  <p>如未特别标明，文章均属原创。转载请注明出处。by : 柳公子 <a href="http://huliuqing.github.io">http://huliuqing.github.io</a></p>
</blockquote>

<p>进行PHP开发工作3年，直到最近才更专注的去思考关于PHP项目性能问题（一直以来有去了解，但并未深入的去学习）。这篇文章简单讲解在windows平台下PHP开发中，安装和使用memcached缓存系统。</p>

<p>先来看看维基百科关于<a href="http://zh.wikipedia.org/wiki/Memcached" target="_blank">memcached</a>的解释：</p>

<blockquote>
  <p>memcached是一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发，但目前被许多网站使用。这是一套开放源代码软件，以BSD license授权发布。
  ...
  memcached的API使用三十二比特的循环冗余校验（CRC-32）计算键值后，将数据分散在不同的机器上。当表格满了以后，接下来新增的数据会以LRU机制替换掉。由于memcached通常只是当作高速缓存系统使用，所以使用memcached的应用程序在写回较慢的系统时（像是后端的数据库）需要额外的代码更新memcached内的数据。</p>
</blockquote>

<p>感觉很高端的样子，简单来说<code>memcached</code>是一套分布式的内存对象缓存系统，<code>Key/Value</code>值对以Hashmap方式缓存到内存中，以降低Web应用对数据库、文件读取的压力。</p>

<h2>memcached缓存系统组成</h2>

<p>一）  memcached服务守护程序</p>

<p>服务器守护程序是用C编写的，为客户端程序提供服务。<a href="http://code.jellycan.com/files/memcached-1.2.6-win32-bin.zip">点这里下载</a></p>

<p>二）  memcache客户端程序</p>

<p>客户端程序可以是任意语言编写的，通过memcached协议与守护程序通信。我们这下载PHP开发相关的版本。<a href="http://downloads.php.net/pierre/" target="_blank">到这里去下载</a></p>

<h2>memcached服务守护程序安装</h2>

<ol>
<li><p>1.下载memcached服务器程序,获取memcached.exe文件。<a href="http://code.jellycan.com/files/memcached-1.2.6-win32-bin.zip">点这里下载</a></p></li>
<li><p>2.进入命令行模式，使用命令安装memcached
c:/memcached/memcached.exe -d install</p></li>
<li><p>3.启动服务
c:/memcached/memcached.exe -d start</p></li>
</ol>

<p>默认情况下memcached服务器程序监听<code>11211</code>端口,并指定缓存使用的最大内存为<code>64MB</code>。</p>

<p>常用memcached选项参数</p>

<pre><code>-m 指定缓存所使用的最大内存容量，单位是Megabytes，默认是64MB
-u 只有以root身份运行时才指定该参数
-d 以daemon的形式运行
-l 指定监听的地址
-p 指定监听的TCP端口号，默认是11211

//"-d"参数更多选项值
-d install 安装memcached
-d uninstall 卸载memcached
-d start 启动memcached服务
-d restart 重启memcached服务
-d stop 停止memcached服务
-d shutdown 停止memcached服务
</code></pre>

<p>更多memcached选项参数，<a href="http://works.jinbuguo.com/man/memcached.html">点这里去了解</a></p>

<h2>memcache客户端安装</h2>

<p>如果使用XAMPP/WAMP集成开发环境，我们仅需下载php_memcache扩展程序。</p>

<ol>
<li><p>1.下载dll扩展程序（<a href="http://downloads.php.net/pierre/" target="_blank">到这里去下载</a>）,放于c:/xampp/php/ext/目录下。</p></li>
<li><p>2.开启扩展服务。
进入php.ini文件添加如下<code>extension=php_memcache.dll</code></p></li>
<li><p>3.重新启动XAMPP/WAMP</p></li>
</ol>

<h2>使用memcache缓存</h2>

<p>超简单示例：</p>

<pre><code>&lt;?php
$memcache = new Memcache;

$memcache-&gt;connect('127.0.0.1',11211);
$memcache-&gt;add('name','柳公子');
$name = $memcache-&gt;get('name');

echo $name;
</code></pre>

<p>进入官网手册，了解更多关于<a href="http://cn2.php.net/manual/zh/book.memcache.php">memcache</a>相关信息</p>

<h2>工具</h2>

<p><a href="http://www.junopen.com/memadmin/" target="_blank">memcache监控程序</a></p>

<p>参考资料：</p>

<p><a href="http://works.jinbuguo.com/man/memcached.html">memcache手册中文</a></p>

<p><a href="http://www.codeforest.net/how-to-install-memcached-on-windows-machine">How to install Memcached on Windows machine</a></p>

<p><a href="http://blog.csdn.net/poechant/article/details/7074257">Memcached基础及示例程序</a></p>

<p><a href="http://blog.csdn.net/poechant/article/details/7082115">Memcached配置参数初解</a></p>

<p><a href="http://zh.wikipedia.org/wiki/Memcached">维基百科：memcached</a></p>

<p><a href="http://baike.baidu.com/view/794242.htm">百度百科：memcached</a></p>

<p><a href="http://cn2.php.net/manual/zh/book.memcache.php">手册：memcached</a></p>
</div>
                            <span class="post-date">2014-05-27 17:55:00</span>
                            <span class="post-tag">php, 缓存技术, memcache</span>
                        </div>
                                            <div class="post">
                            <h2><a href="http://huliuqing.github.io/2014-05-26-translate-PHP-website-optimization.html">如何优化PHP网站[译]</a></h2>
                            <div class="post-content"><p>转载请注明出处</p>

<p>这是一篇翻译自stackOverflow的文章，由于水平有限难免出错，如果您在阅读的时候发现了，请帮我更正。</p>

<h2>如何优化PHP网站</h2>

<p>问题如下（原文：<a href="http://stackoverflow.com/questions/8258567/php-website-optimization/8259911#8259911">PHP website Optimization</a>）：
    我拥有一个高访问量的网站，需要保证每个访问我站点的用户，都能够在最短的时间内显示出他们请求的页面。
    我通过Google搜索大量关于网站访问速度和优化方法的文章，并得出如下几个方案：</p>

<pre><code>    1. 对页面缓存
        通过对页面缓存，我可以让访问更加快速。但是如果我变更了页面的内容，我则必须把页面的内容从缓存中删除并重新对文件进行缓存。
    2. 页面静态化（把页面保存在磁盘中）
        通过页面静态化，我可以比较简单的对它进行维护。只是这样的话我必须每次访问它所在的目录来进行维护工作。
</code></pre>

<p>那么究竟如何才能够达到我想要的目的呢？</p>

<h2>------------------------------------------------------------------------------------------</h2>

<h2>来自Book Of Zeus的回答:</h2>

<p><a href="http://stackoverflow.com/a/8259911/3675700">Book Of Zeus</a></p>

<p>对于网站的性能来说，当我们需要获取静态或动态的内容时，减少访问数据库或文件系统的请求数，启用缓存（缓存页面或部分内容）是很重要的一个环节。</p>

<p>在运行动态内容的时候，我们可以使用加速PHP处理的软件：</p>

<p>（一）在这我推荐使用Alternative PHP Cache(<a href="http://php.net/manual/en/book.apc.php">通过手册了解更多关于APC信息</a>)。</p>

<p>推荐几篇关于APC的好文章给你：</p>

<ol>
<li><p>1.<a href="http://agilewebmasters.com/robert/what-is-the-best-php-accelerator-to-use/">What is the best PHP accelerator to use?
</a></p></li>
<li><p>2.<a href="http://blog.digitalstruct.com/2007/12/23/php-accelerators-apc-vs-zend-vs-xcache-with-zend-framework/">PHP Accelerators : APC vs Zend vs XCache with Zend Framework</a></p></li>
<li><p>3.<a href="http://blog.bodhizazen.net/linux/lighttpd-php-acceleration-benchmarks/">Lighttpd – PHP Acceleration Benchmarks</a></p></li>
</ol>

<p>（二）如果是缓存内容或整个页面的话，最好使用<a href="http://memcached.org">Memcached</a> 或 <a href="http://redis.io">Redis</a>进行缓存。</p>

<ol>
<li><p>1.<code>memcached</code>
一个高性能的分布式内存对象缓存开源系统。用于降低数据库负载，提升动态web程序的访问速度。memcached是通过把从数据库中返回的结果集、调用API返回的结果集或者呈现的页面。在内存中以键值对的形式进行缓存。</p></li>
<li><p>2.<code>Redis</code>
一款高性能键值对存储数据库开源项目。当值为字符，哈希表，列表，集合或排序集合时，它被视作一种数据结构服务程序。</p></li>
</ol>

<p>这两个(Memcached和Redis)项目都是用于缓存内容和变量的绝好工具。</p>

<p>推荐几篇有关Memcached和Redis的相关文章：</p>

<ol>
<li><p>1.<a href="http://trespams.com/2011/08/05/redis-vs-memcached-en/">Redis vs Memcached</a></p></li>
<li><p>2.<a href="On Redis, Memcached, Speed, Benchmarks and The Toilet">On Redis, Memcached, Speed, Benchmarks and The Toilet</a></p></li>
<li><p>3.<a href="http://systoilet.wordpress.com/2010/08/09/redis-vs-memcached/">Redis vs Memcached</a></p></li>
<li><p>4.<a href="http://dormando.livejournal.com/525147.html">Redis VS Memcached (slightly better bench)</a></p></li>
</ol>

<p>（三）使用varnish，nginx或G-Wan</p>

<ol>
<li><p>1.<code>Varnish</code>
一款专为有大量动态内容web网站设计的HTTP加速器。与其它HTTP加速器相比，如squid在客户端缓存;Apache则仅仅是服务器软件。Varnish则一开始就被设计成为HTTP加速器。</p></li>
<li><p>2.<code>Nginx</code>
是一款由俄罗斯程序员Igor Sysoev所开发轻量级的网页服务器、反向代理服务器以及电子邮件（IMAP/POP3）代理服务器。起初是供俄国大型的门户网站及搜索引擎Rambler（俄语：Рамблер）使用。此软件BSD-like协议下发行，可以在UNIX、GNU/Linux、BSD、Mac OS X、Solaris，以及Microsoft Windows等操作系统中运行</p></li>
<li><p>3.<code>g-wan</code>
C编写的Web服务器，比其它采用键值对存储的解决方案更加快速</p></li>
</ol>

<p>一些文章：   </p>

<ol>
<li><p>1.<a href="http://nbonvin.wordpress.com/2011/03/14/apache-vs-nginx-vs-varnish-vs-gwan/">Serving static files: a comparison between Apache, Nginx, Varnish and G-WAN</a></p></li>
<li><p>2.<a href="http://loadstorm.com/2011/05/web-server-performance-benchmarks/">Web Server Performance Benchmarks</a></p></li>
<li><p>3.<a href="http://www.garron.me/en/go2linux/nginx-varnish-vs-nginx-alone-compared.html">Nginx+Varnish compared to Nginx</a></p></li>
<li><p>4.<a href="http://cd34.com/blog/infrastructure/apache-varnish-nginx-and-lighttpd/">Apache, Varnish, nginx and lighttpd</a></p></li>
<li><p>5.<a href="http://www.wikivs.com/wiki/G-WAN_vs_Nginx">G-WAN vs Nginx</a></p></li>
</ol>

<p>(to be continued)</p>
</div>
                            <span class="post-date">2014-05-26 18:00:00</span>
                            <span class="post-tag">php, Web, 优化, PHP优化</span>
                        </div>
                                            <div class="post">
                            <h2><a href="http://huliuqing.github.io/2014-05-26-introduce-php-test-tool-ab.html">Apache Bench 工具介绍</a></h2>
                            <div class="post-content"><blockquote>
  <p>如未特别标明，文章均属原创。转载请注明出处 
      by : 柳公子 <a href="http://huliuqing.github.io ">http://huliuqing.github.io </a></p>
</blockquote>

<p>apache benchmark（以下简称ab）是一款基准测试工具,用于描绘当前安装的apache服务器的执行性能,是apache安装的一部分。用户可以模拟对特定URL的任意数量请求来对Web服务器进行负载测试，观察你的apache服务器每秒可以处理多少请求。</p>

<p>ab工具提供以下信息：</p>

<ul>
<li>传输的总大小</li>
<li>Web服务器在模拟流量下每秒可以支持的请求总数</li>
<li>完成一个请求所花费的最长时间</li>
<li>完成一个请求所花费的最少时间</li>
</ul>

<h2>ab语法</h2>

<pre><code>ab
    [-A auth-username:password]
    [-c concurrency]
    [-C cookie-name=value]
    [-d]
    [-e csv-file]
    [-g gnuplot-file]
    [-h]
    [-H custom-header]
    [-i]
    [-k]
    [-n requests]
    [-p POST-file]
    [-P proxy-auth-username:password]
    [-q]
    [-s]
    [-S]
    [-t timelimit]
    [-T content-type]
    [-v verbosity]
    [-V]
    [-w]
    [-x &lt;table&gt;-attributes]
    [-X proxy[:port]]
    [-y &lt;tr&gt;-attributes]
    [-z &lt;td&gt;-attributes]
[http://]hostname[:port]/path
</code></pre>

<h2>ab选项标记</h2>

<pre><code>-A auth-username:password 
向服务器提供基本认证信息。用户名和密码之间由一个":"隔开，并将被以base64编码形式发送。无论
服务器是否需要(即是否发送了401认证需求代码)，此字符串都会被发送。 

-c concurrency 
一次产生的请求个数。默认设置为1。 

-C cookie-name=value 
对请求附加一个"Cookie:"头行。其典型形式是 name=value 的一个参数对。此参数可以重复。

-d 
不显示"percentage served within XX [ms] table"消息(为以前的版本提供支持)。 

-e csv-file 
产生一个逗号分隔(CSV)文件，该文件包含基准测试的运行结果(其中包含了处理每个相应
百分比[Percentage served]请求(从1%到100%)所需要的相应百分比时间[Time in ms](以微
秒为单位))。由于这种格式已经"二进制化"，所以比"gnuplot"格式更有用。 

-g gnuplot-file 
把所有测试结果写入一个"gnuplot"或者TSV(以Tab分隔)文件。此文件可以方便地导入到 Gnuplot,
IDL, Mathematica, Excel中。其中的第一行为标题。 

-h 
显示要用于ab的选项列表。 

-H custom-header 
对请求附加额外的头信息。此参数的典型形式是一个有效的头信息行，其中包含了以冒号分隔的字段
和值(如："Accept-Encoding: zip/zop;8bit")。 

-i 
执行HEAD请求，而不是默认的GET请求 。 

-k 
启用KeepAlive功能，即在一个HTTP会话中执行多个请求。默认不启用KeepAlive功能。 

-n requests 
在测试会话中所执行的请求个数。默认仅执行一个请求，此时其结果不具有意义，n值最大为50000。

-p POST-file 
包含了POST数据的文件。 

-P proxy-auth-username:password 
对一个中转代理提供基本认证信息。用户名和密码由一个":"隔开，并将被以base64编码形式发送。
无论服务器是否需要(即是否发送了407代理认证需求代码)，此字符串都会被发送。 

-q 
如果处理的请求数大于150，ab每处理大约10%或者100个请求时，会在stderr输出一个进度计数。此 
-q 标记可以屏蔽这些信息。

-s 
用于编译中(ab -h 会告诉你)使用了SSL的受保护的https ，而不是http协议的时候。此功能是实验性的，最好不要用。 

-S 
不显示中值和标准偏差值，而且在均值和中值为标准偏差值的1到2倍时，也不显示警告或出错信息。
默认时，会显示最小值/均值/最大值等数值。(为以前的版本提供支持) 

-t timelimit 
测试所进行的最大秒数。内部隐含值是"-n 50000"。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。

-T content-type 
POST数据时所使用的"Content-type"头信息。 

-v verbosity 
设置显示信息的详细程度，4或更大值会显示头信息，3或更大值可以显示响应代码(404，200等)，2或更大值可以显示警告和其他信息。 

-V 
显示版本号并退出。 

-w 
以HTML表格形式输出结果。默认时，它是白色背景的两列宽度的一张表。 

-x &lt;table&gt;-attributes 
设置&lt;table&gt;属性的字符串。此属性被填入&lt;table 这里 &gt; 。 

-X proxy[:port] 
对请求使用代理服务器。 

-y &lt;tr&gt;-attributes 
设置&lt;tr&gt;属性的字符串。 

-z &lt;td&gt;-attributes 
设置&lt;td&gt;属性的字符串。 
</code></pre>

<h2>运行ab工具</h2>

<p>现在我们要运行ab工具来对http://www.github.com来进行基准测试。
运行如下命令：</p>

<p>ab -n 1 http://www.github.com/</p>

<p>输出结果如下</p>

<pre><code>Server Software:
Server Hostname:        www.github.com
Server Port:            80
#服务器信息


Document Path:          /
Document Length:        0 bytes
#文档信息


Concurrency Level:      1
Time taken for tests:   1.651 seconds
Complete requests:      1
Failed requests:        0
Write errors:           0
Non-2xx responses:      1
Total transferred:      107 bytes
HTML transferred:       0 bytes
Requests per second:    0.61 [#/sec] (mean)
Time per request:       1650.709 [ms] (mean)
Time per request:       1650.709 [ms] (mean, across all concurrent requests)
Transfer rate:          0.06 [Kbytes/sec] received
#连接信息


Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:      862  862   0.0    862     862
Processing:   788  788   0.0    788     788
Waiting:      788  788   0.0    788     788
Total:       1650 1650   0.0   1650    1650
#连接指标分类
</code></pre>

<h2>1. 服务器信息部分</h2>

<p>一般我们的Web服务器软件会是apache，那么在Server Software : 中会显示 apache : 。
但是由于Web管理员使用安全措施，该字段可能返回其它内容或什么也不返回（如示例）</p>

<pre><code>Server Hostname : 测试主机名
Server Post : 测试主机的Web服务器监听端口号
</code></pre>

<h2>2. 脚本信息部分</h2>

<p>包含基准测试主机的Web文档的信息内容</p>

<pre><code>Document Path :  包含测试请求的文档
Document Length : 包含所有HTML 、CSS、JS、图像及其响应的其它数据的字节数总和
</code></pre>

<h2>3. 链接信息部分</h2>

<p>连接数据包含基准测试信息最核心的反馈信息。
其中最需要关心的内容部分：</p>

<pre><code>    HTML transferred    整个模拟测试中传输的内容正文总大小
    Requests per second 每秒支持的请求数
    Time per request    满足一个请求需要花费的总时间
</code></pre>

<p>优化目标：减少HTML transferred 大小，提高Requests per second并降低Time per request值</p>

<h2>4. 连接指标分类</h2>

<p>在这一部分我们主要关注Total项目中的min : ,max : 列</p>

<pre><code>min : 请求所花费的最短时间
man : 请求所花费的最长时间
</code></pre>

<h2>参考资料</h2>

<p><a href="http://apache.chinahtml.com/programs/ab.html">apache 中文手册</a> </p>

<p>未完待续</p>
</div>
                            <span class="post-date">2014-05-26 14:51:52</span>
                            <span class="post-tag">php, apache, 压力测试, 工具</span>
                        </div>
                                            <div class="post">
                            <h2><a href="http://huliuqing.github.io/2014-05-15-analyze-object-iterator-in-php.html">详解PHP中对象属性遍历</a></h2>
                            <div class="post-content"><h2>对象迭代</h2>

<p><blockquote>
    如未特别标明，文章均属原创。转载请注明出处 </p>

<p>by : 柳公子 <a href="http://huliuqing.github.io">http://huliuqing.github.io</a>
</blockquote></p>

<p>php官网手册对于<a href="http://www.php.net/manual/zh/language.oop5.iterations.php" target="_blank">遍历对象</a>解释如下：
<blockquote>PHP 5 提供了一种定义对象的方法使其可以通过单元列表来遍历，例如用 foreach 语句。默认情况下，所有可见属性都将被用于遍历。 </blockquote></p>

<p>不过使用简单的foreach遍历对象，仅仅能够遍历出对象实例中可见（public)属性的值。</p>

<p>foreach是如何实现对对象进行遍历的呢？</p>

<p>我们的鸟哥在<a href="http://www.laruence.com/2008/10/31/574.html" >关于一笔试题(Iterator模式) </a>一文中分享过foreach源码实现。这边我就拿来主义了：</p>

<pre><code>switch (zend_iterator_unwrap(array, &amp;iter TSRMLS_CC)) {
    default:
        case ZEND_ITER_INVALID:
               .....
               break
        case ZEND_ITER_PLAIN_OBJECT: {
                ......
            break;
     case ZEND_ITER_PLAIN_ARRAY:
            .....
            break;

        case ZEND_ITER_OBJECT:
            ......
            break;
}
</code></pre>

<p>具体如何使用<code>foreach</code>遍历对象，查看示例：</p>

<pre><code>&lt;?php

class Student{
    private $_identityCard = '360401190001011018';
    public  $_name = '三丰';
    public  $_age  = 800;

    protected $_bloodType = 'O';

    public function __construct(){}
}

$s = new Student();

foreach($s as $key =&gt; $v){
    echo 'key ',$key ,' val ',$v ,'&lt;/br&gt;';
}

//输出
key :_name val 三丰
key :_age val 800
</code></pre>

<p>从输出的结果来看，实例化对象的所有可见(<code>public</code>)属性都给遍历输出出来了。</p>

<p>但是，当我们需要遍历那些非可见对象属性，明显简单的使用<code>foreach</code>遍历对象就不够用了。</p>

<p>好在PHP中有提供内置遍历接口<code>Iterator</code> 和 <code>IteratorAggregate</code>完成对象的遍历工作。
关于Iterator与IteratorAggregate接口如下：</p>

<pre><code>Iterator extends Traversable {
    /* 方法 */
    abstract public mixed current ( void )//返回当前元素。 
    abstract public scalar key ( void )   //返回当前元素的键
    abstract public void next ( void )    //移动当前位置到下一个元素
    abstract public void rewind ( void )  //返回到迭代器的第一个元素
    abstract public boolean valid ( void )//此方法在 Iterator::rewind() 和 Iterator::next()
                                          //方法之后被调用以此用来检查当前位置是否有效
}

IteratorAggregate extends Traversable {
    /* 方法 */
    abstract public Traversable getIterator ( void )//返回一个外部迭代器
}
</code></pre>

<p>我们可以通过实现这两个迭代器接口，定义自己的对象遍历规则</p>

<p>1、通过实现IteratorAggregate接口，完成对象属性遍历</p>

<p>我们只需要实现IteratorAggregate中getIterator()方法完成遍历。</p>

<pre><code>class Kungfu implements IteratorAggregate{
    public $_name='飞鸿';
    public $_age = 121;

    protected $_bloodType = 'O';
    private $_isMarried = true;

    public function __construct(){}

    public function getIterator(){
        $members = get_class_vars(__CLASS__);

        return new ArrayIterator($members);
    }
}


$k = new Kungfu();

foreach($k as $key =&gt; $v){
    echo 'key ',$key ,' val ',$v ,'&lt;/br&gt;';
}
/*
    key _name val 飞鸿
    key _age val 121
    key _bloodType val O
    key _isMarried val 1
*/
</code></pre>

<p>2、通过实现Iterator接口，完成对象属性遍历</p>

<p>相对于<code>IteratorAggregate</code>而言，<code>Iterator</code>接口实现起来稍微麻烦一些，需要在实现类中实现所有5个抽象方法。</p>

<p>不过如果我们需要对迭代的对象，进行具体控制的话，使用<code>Iterator</code>的话则更合适。</p>

<pre><code>class Language implements Iterator{
    private $_lang;
    private $_counter=0;

    public function __construct(){      
        $this-&gt;_lang = explode(',', 'PHP,C++,C,GO,JAVA,JAVASCRIPT,RUBY,Node.js');
    }

    public function rewind(){
        $this-&gt;_counter = 0;
    }

    public function current(){
        //当编程语言的值为JAVA时，返回空
        if($this-&gt;_lang[$this-&gt;_counter] == 'JAVA'){
            return null;
        }
        return $this-&gt;_lang[$this-&gt;_counter];
    }

    public function valid(){
        return isset( $this-&gt;_lang[$this-&gt;_counter]);
    }

    public function next(){
        ++$this-&gt;_counter;
    }
    public function key(){
        return $this-&gt;_counter;
    }
}

$m = new Language();

foreach($m as $key =&gt; $v){
    echo 'key ',$key ,' val ',$v ,'&lt;/br&gt;';
}

//结果输出
key 0 val PHP
key 1 val C++
key 2 val C
key 3 val GO
key 4 val 
key 5 val JAVASCRIPT
key 6 val RUBY
key 7 val Node.js
</code></pre>

<p>接口<code>Iterator</code>中抽象方法的执行顺序如下图所示：
<img src="http://huliuqing.github.io/images/post-source/2014-05-analyze-object-iterator-in-php.png" title="Iterator抽象方法调用顺序"></img></p>
</div>
                            <span class="post-date">2014-05-15 10:41:30</span>
                            <span class="post-tag">php, 对象, 遍历, Iterator, Object</span>
                        </div>
                                            <div class="post">
                            <h2><a href="http://huliuqing.github.io/2014-05-07-how-to-learning-algorithm-reprint.html">我的算法学习之路 - [转载]</a></h2>
                            <div class="post-content"><p>原文链接：<a href="http://zh.lucida.me/blog/on-learning-algorithms/" target="_blank">我的算法学习之路</a></p>

<p>原文作者：<a href="http://zh.lucida.me/blog/on-learning-algorithms/" target="_blank">Lucida</a></p>

<h2>这篇文章讲了什么？</h2>

<ul>
<li><p>我这些年学习数据结构和算法的总结。</p></li>
<li><p>一些不错的算法书籍和教程。</p></li>
<li><p>算法的重要性。</p></li>
</ul>

<h2>初学 ##</h2>

<p>第一次接触数据结构是在大二下学期的数据结构课程。然而这门课程并没有让我入门——当时自己正忙于倒卖各种MP3和耳机，对于这些课程根本就不屑一顾——反正最后考试划个重点也能过，于是这门整个计算机专业本科最重要的课程就被傻逼的我直接忽略过去了。</p>

<p>直到大三我才反应过来以后还要找工作——而且大二的折腾证明了我并没有什么商业才能，以后还是得靠码代码混饭吃，我当时惊恐的发现自己对编程序几乎一无所知，于是我给自己制订了一个类似于建国初期五年计划的读书成长计划，其中包括C语言基础、数据结构以及计算机网络等方面的书籍。</p>

<p>读书计划的第一步是选择书籍，我曾向当时我觉得很牛的”学长”和”大神”请教应该读哪些算法书籍，”学长”们均推荐算法导论，还有几个”大神”推荐计算机程序设计艺术（现在我疑心他们是否翻过这些书），草草的翻了下这两本书发现实在看不懂，但幸运的是我在无意中发现了豆瓣这个神奇的网站，里面有很多质量不错的书评，于是我就把评价很高而且看上去不那么吓人的计算机书籍都买了下来——事实证明豆瓣要比这些”学长”或是”大神”靠谱的多得多。</p>

<h2>数据结构与算法分析——C语言描述</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-1.jpg"></p>

<p><a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我学习数据结构的第一本书：当时有很多地方看不懂，于是做记号反复看；代码看不明白，于是抄到本子上反复研读；一些算法想不通，就把它所有的中间状态全画出来然后反复推演。事实证明尽管这种学习方法看起来傻逼而且效率很低，但对于当时同样傻逼的我却效果不错——傻人用傻办法嘛，而且这本书的课后题大多都是经典的面试题目，以至于日后我看到<a href="http://book.douban.com/subject/3004255/">编程之美</a>的第一反应就是这货的题目不全是抄别人的么。</p>

<p>至今记得，这本书为了说明算法是多么重要，在开篇就拿最大子序列和作为例子，一路把复杂度从O(N3)杀到O(N2)再到O(NlgN)最后到O(N)，当时内心真的是景仰之情=如滔滔江水连绵不绝，尼玛为何可以这么屌，</p>

<p>此外，我当时还把这本书里图算法之前的数据结构全手打了一遍，后来找实习还颇为自得的把这件事放到简历里，现在想想真是傻逼无极限。</p>

<p>凭借这个读书成长计划中学到的知识，我总算比较顺利的找到了一份实习工作，这是后话。</p>

<h2>入门</h2>

<p>我的实习并没有用到什么算法（现在看来就是不停的堆砌已有的API，编写一堆自己都不知道对不对的代码而已），在发现身边的人工作了几年却还在和我做同样的事情之后，我开始越来越不安。尽管当时我对自己没什么规划，但我清楚这绝壁不是我想做的工作。</p>

<h2>微软的梦工厂</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-2.jpg"></p>

<p>在这个摇摆不定的时刻，<a href="http://book.douban.com/subject/3238803/">微软的梦工场</a>成了压倒骆驼的最后一支稻草，这本书对微软亚洲研究院的描写让我下定了”找工作就要这样的公司”的决心，然而我又悲观的发现无论是以我当时的能力还是文凭，都无法达到微软亚研院的要求，矛盾之下，我彻底推翻了自己”毕业就工作”的想法，辞掉实习，准备考研。</p>

<p>考研的细节无需赘述，但至今仍清楚的记得自己在复试时惊奇且激动的发现北航宿舍对面就是微软西格玛大厦，那种离理想又进了一步的感觉简直爽到爆。</p>

<h2>算法设计与分析</h2>

<p>我的研究生生涯绝对是一个反面典型——翘课，实习，写水论文，做水研究，但有一点我颇为自得——从头到尾认真听了韩军教授的算法设计与分析课程。</p>

<p>韩军给我印象最深的有两点：课堂休息时跑到外面和几个学生借火抽烟；讲解算法时的犀利和毫不含糊。</p>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-3.jpg"></p>

<p>尽管韩军从来没有主动提及，但我敢肯定<a href="http://book.douban.com/subject/3238803/">算法设计与分析基础</a>就是他算法课程事实上的（de-facto）教材，因为他的课程结构几乎和这本书的组织结构一模一样。</p>

<p>如果<a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我的数据结构启蒙，那么韩军的课程和<a href="http://book.douban.com/subject/3238803/">算法设计与分析基础</a>就是我的算法启蒙，结合课程和书籍，我一一理解并掌握了复杂度分析、分治、减治、变治、动态规划和回溯这些简单但强大的算法工具</p>

<h2>算法引论</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-4.jpg"></p>

<p><a href="http://book.douban.com/subject/4178907/">算法导论</a>是我这时无意中读到的另一本算法书，和普通的算法书不同，这本书从创造性的角度出发——如果说算法导论讲的是有哪些算法，那么算法引论讲的就是如何创造算法。结合前面的<a href="http://book.douban.com/subject/3238803/">算法设计与分析基础</a>，这本书把我能解决的算法问题数量扩大了一个数量级。</p>

<p>之后，在机缘巧合下，我进入微软亚洲工程院实习，离理想又近了一步，自我感觉无限牛逼。</p>

<h2>巩固</h2>

<p>在微软工程院的实习是我研究生阶段的一个非常非常非常重要的转折点：</p>

<ul>
<li>做出了一个还说的过去的小项目。</li>
<li>期间百度实习面试受挫，痛定思痛之下阅读了大量的程序设计书。</li>
<li>微软的实习经历成为了我之后简历上为数不多的亮点之一（本屌一没成绩，二没论文，三没ACM）。</li>
</ul>

<p>这里就不说1和3了（和本文题目不搭边），重点说说2。</p>

<p>由于当时组内没有特别多的项目，我负责的那一小块又提前搞定了，mentor便很慷慨的扔给我一个Kinect和一部Windows Phone让我研究，研究嘛，自然就没有什么deadline，于是我就很鸡贼的把时间三七开：七分倒腾Windows Phone，三分看书&amp;经典论文。</p>

<p>然而一件事打断了这段安逸的生活——</p>

<h2>百度实习面试</h2>

<p>基友在人人发百度实习内推贴，当时自我感觉牛逼闪闪放光芒，于是就抱着看看国内IT环境+虐虐面试官的变态心理投了简历，结果在第一面就自己的师兄爆出翔：他让我写一个stof（字符串转浮点数），我磨磨唧唧半天也没写出完整实现，之后回到宿舍赶快写了一个版本发到师兄的邮箱，结果对方压根没鸟我。</p>

<p>这件事对我产生了很大的震动——</p>

<ul>
<li><p>原来自己连百度实习面试都过不去。</p></li>
<li><p>原来自己还是一个编程弱逼。</p></li>
<li><p>原来自己还是一个算法菜逼。</p></li>
</ul>

<p>痛定思痛，我开始了第二个”五年计划”，三七开的时间分配变成了七三开：七分看书，三分WP。而这一阶段的重点从原理（Principle）变成了实现（Implementation）——Talk is cheap, show me the code.</p>

<h2>Elements of Programming</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-5.jpg"></p>

<p>由于一直觉得名字里带”Elements of”的都是酷炫叼炸天的书，所以我几乎是毫不犹豫的买了这本<a href="http://book.douban.com/subject/3802826/">Elements of Programming</a>，事实上这本书里的代码（或者说STL的代码）确实是：快，狠，准，古龙高手三要素全齐。</p>

<h2>C Interfaces and Implementation</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-6.jpg"></p>

<p>百度面试被爆出翔的经历让我意识到另一个问题，绝大多数公司面试时都需要在纸上写C代码，而我自己却很少用C（多数情况用C#），考虑到自己还没牛逼到能让公司改变面试流程的地步，我需要提升自己编写C代码的能力（哪怕只是为了面试）。一顿Google之后，我锁定了<a href="http://book.douban.com/subject/1826926/">C Interfaces and Implementation</a>——另一本关于如何写出狂炫酷帅叼炸天的C代码的奇书，这里套用下Amazon的评论：Probably the best advanced C book in existance。</p>

<p>严格来说上面两本书都不是传统的算法书，因为它们侧重的都不是算法，而是经典算法的具体实现（Implementation），然而这正是我所需要的：因为算法的原理我能说明白，但要给出优雅正确简练的实现我就傻逼了，哪怕是stof这种简单到爆的”算法”。</p>

<p>依然是以前的傻逼学习方法：反复研读+一遍又一遍的把代码抄写到本子上，艰难的完成了这两本书后，又读了相当数量的编程实践（Programming Practice）书籍，自我感觉编程能力又大幅提升，此外获得新技能——纸上编码。这也成为了我之后找工作面试的三板斧之一。</p>

<h2>应用</h2>

<p>说老实话，自从本科实习之后，我就一直觉得算法除了面试时能用用，其它基本用不上，甚至还写了一篇当时颇为自得现在读起来极为傻逼的文章来黑那些动不动就”基础”或”内功”的所谓”大牛”们，这里摘取一段现在看起来很傻逼但当时却觉得是真理的文字：</p>

<blockquote>所以那些动则就扯什么算法啊基础啊内功啊所谓的大牛们，请闭上你的嘴，条条大道通罗马。算法并不是编程的前提条件，数学也不会阻碍一个人成为优秀的程序员。至少在我看来，什么算法基础内功都是唬人的玩意，多编点能用的实用的程序才是王道，当然如果你是一个pure theorist的话就当我什么都没说好了。</blockquote>

<p>然而有意思的是，写了这篇<a href="http://book.douban.com/review/3733680/" target="_black">文章</a>没多久，鼓吹算法无用论的我自己做的几个大大小小的项目全部用到了算法——我疑心是上天在有意抽我的脸</p>

<h2>LL(k)</h2>

<p>我在微软实习的第一个项目做的是代码覆盖率分析——计算T-SQL存储过程的<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B">代码覆盖率</a>。</p>

<p>简单的看了下SQL Server相关的文档，我很快发现SQL Reporting Service可以记录T-SQL的执行语句及行号，于是行覆盖（line coverage）搞定，但老大说行覆盖太naive，我们需要更实际的块覆盖（block coverage）。</p>

<p>阅读了块覆盖的定义后，我发现我需要对T-SQL进行语法分析，在没有找到一个好用的T-SQL Parser的情况下，只能自己动手搞一个：</p>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-7.jpg"></p>

<p>比较奇诡的是，做这个项目时当时我刚好把ANTLR作者的<a href="http://book.douban.com/subject/4030327/">Language Implementation Patterns</a>看了一半，什么LL(k)啊Packrat啊AST Walker的概念啊正热乎着呢。</p>

<p>于是，自己自己就照着T-SQL的官方EBNF，三下五除二撸了一个T-SQL存储过程的LL(k) Parser，把代码转换成AST，然后用一个External AST Walker生成代码块覆盖的HTML报表，全部过程一周不到。</p>

<p>老大自然是很满意——我疑心他的原计划是花两三个月来完成这个项目，因为这个项目之后的两个月我都没什么活干，天天悠哉游哉。</p>

<h2>拼音索引</h2>

<p>比如说输入中国：
    <a href="">sorry 图片未找到</a></p>

<p>同样，输入拼音也应给出提示：<br />
    <a href="">sorry 图片未找到</a></p>

<p>中文匹配这个简单，但拼音匹配就得花时间想想了——懒得造轮子的我第一时间找到了微软的拼音库，但接下来我就发现微软这个鸟库在手机上跑不动，研究了下发现WP7对Dictionary的items数量有限制，貌似是7000还是8000个item就会崩盘，而标准汉字则有两万多个，尼玛。</p>

<p>痛骂MS坑爹+汉字坑爹之余，还是得自己撸一个库出来：</p>

<ul>
<li>首先把那两万个汉字搞了出来，排序，然后弄成一个超长的字符串。</li>
<li>接下来用Int16索引了汉字所有的拼音（貌似500多个）。</li>
<li>再接下来用Int64建立汉字和拼音的关联——汉字有多音字，所以需要把多个拼音pack到一个Int64里，这个简单，位操作就搞定。</li>
<li>最后用二分+位移Unpack，直接做到从汉字到拼音的检索。</li>
<li>后来小测了下性能，速度是MS原来那个库的五十倍有余，而代码量只有336行。</li>
</ul>

<p>用户很happy——因为我捎带把他没想到的多音字都搞定了，而且流畅的一逼。</p>

<p>我也很happy，因为没想到自己写的库居然比MS的还要快几十倍，同时小十几倍。</p>

<p>从这个事情之后我变得特别理解那些造轮子的人——你要想想，如果你需要一个飞机轮子但市场上只有自行车轮子而且老板还催着你交工，你能怎么搞。</p>

<h2>快速字符串匹配</h2>

<p>前面提到在微软实习时老大扔给我一个Windows Phone让我研究下，我当时玩了玩就觉着不太对劲，找联系人太麻烦。</p>

<p>比如说找”张晓明”，WP只支持定位到Z分类下——这意味着我需要在Z分类下的七十多个联系人（姓张的姓赵的姓钟的等等）里面线性寻找，每次我都需要滑动四五秒才能找到这个张姓少年。
<a href="">sorry 图片未找到</a></p>

<p>这TMD也太傻逼了，本屌三年前的老破NOKIA都支持首字母定位，996->ZXM->张晓明，直接搞定，尼玛一个新时代Windows Phone居然会弱到这个程度。</p>

<p>搜了一下发现没有好用的拨号程序，于是本屌就直接撸了一个支持首字母匹配的拨号程序出来扔到WP论坛里。</p>

<p>结果马上就有各种问题出现——最主要的反映是速度太慢，一些用户甚至反馈按键有时要半秒才有反应。本屌问了下他的通讯录大小：大概3000多人。</p>

<p><a href="">sorry 图片未找到</a></p>

<p>吐槽怎么会有这么奇葩的通讯录之余，我意识到自己的字符串匹配算法存在严重的性能问题：读取所有人的姓名计算出拼音，然后一个个的匹配——结果如果联系人数量太多的话，速度必然拙计。</p>

<p>于是我就开始苦思冥想有没有一个能够同时搜索多个字符串的高端算法，以至于那两天坐地铁都在嘟囔怎么才能把这个应用搞的快一些。</p>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-8.jpg"></p>

<p>最终还是在<a href="http://book.douban.com/subject/1765938/">Algorithms on Strings, Trees and Sequences</a>里找到了答案——确实有能够同时搜索多个字符串的方法：Tries，而且这本书还用足足一章来讲怎么弄Multiple string comparison，看得我当时高潮迭起，直呼过瘾。</p>

<p>具体细节不多说，总之换了算法之后，匹配速度快了大约九十多倍，而且代码还短了几十行。哪怕是有10000个联系人，也能在0.1秒内搞定，速度瓶颈就这样愉快的被算法搞定。</p>

<h2>Writing Efficient Programs</h2>

<p>之后又做了若干个项目，多多少少都用到了”自制”的算法或数据结构，最奇诡的一次是写一个电子书阅读器里的分页，我照着模拟退火（Simulated Annealing）的原理写了一个快速分页算法，事实上这个算法确实很快——但问题是我都不知道为啥它会这么快。</p>

<p>总之，算法是一种将有限计算资源发挥到极致的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀（因为算法不要钱嘛！要不还得换CPU买SSD升级RAM，肉疼啊！！）。一些人会认为这种说法是有问题，因为编写新算法的人力成本有时比增加硬件的成本还要高——但别忘了增加硬件提升效率也是建立在算法是Scalable的基础上——说白了还是得撸算法。</p>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-9.jpg"></p>

<p>说到优化这里顺带提一下<a href="http://book.douban.com/subject/1768600/">Writing Efficient Programs</a>——很难找到一本讲代码优化的书（我疑心是自从Knuth说了过早优化是万恶之源之后没人敢写，万恶之源嘛，写它干毛），注意这本书讲的是代码优化——在不改变架构、算法以及硬件的前提之下进行的优化。尽管书中的一些诸如变量复用或是循环展开的trick已经过时，但总体仍不失为一本好书。</p>

<h2>提高</h2>

<p>实习实习着就到了研二暑假，接下来就是求职季。</p>

<p>求职季时我有一种莫名的复仇感——尼玛之前百度实习面试老子被你们黑的漫天飞翔，这回求职老子要把你们一个个黑回来，尼玛。</p>

<p>现在回想当时的心理实属傻逼+幼稚，但这种黑暗心理也起了一定的积极作用：我丝毫不敢有任何怠慢，以至于在5月份底我就开始准备求职笔试面试，比身边的同学早了两个月不止。</p>

<p>我没有像身边的同学那般刷题——而是继续看书抄代码学算法，因为我认为那些难得离谱的题面试官也不会问——事实上也是如此。</p>

<h2>Algorithm Design Manual</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-10.jpg"></p>

<p>因为很多Coding Interview的论坛都提到这本<a href="http://book.douban.com/subject/3872383/">红皮书</a>，我也跟风搞了一本。事实证明，仅仅是关于Backtrack Template那部分的描述就足以值回书价，更不用说它的Heuristics和课后题。</p>

<h2>编程珠玑&amp;更多的编程珠玑</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-11.jpg"></p>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-12.jpg"></p>

<p>这两本书就不用多介绍，<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>和<a href="http://book.douban.com/subject/1944826/">更多的编程珠玑</a>，没听说过这两本书请自行面壁。前者偏算法理论，后者偏算法轶事，前者提升能力，后者增长谈资，都值得一读。</p>

<h2>The Science of Programming</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-13.jpg"></p>

<p>读到<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>里面关于Binary Search的正确性证明时我大呼过瘾，原来程序的正确性也是可以推导的，然后我就在那一章的引用里发现David Gries的<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>。看名字就觉得很厉害，直接搞了一本开撸。</p>

<p>不愧为编程珠玑引用的书籍，撸完The Science of Programming之后，本屌获得了证明简单代码段的正确性这个技能——求职面试三板斧之二。</p>

<p>证明简单代码段的正确性是一个很神奇的技能——因为面试时大多数公司都会要求在纸上写一段代码，然后面试官检查这段代码，如果你能够自己证明自己写的代码是正确的，面试官还能挑剔什么呢？</p>

<p>之后就是各种面试，详情见之前的博客，总之就是项目经历、纸上代码加正确性证明这三板斧，摧枯拉朽。</p>

<h2>进化</h2>

<p>求职毕业季之后就是各种Happy，Happy过后本屌发现即将面临另一个问题：算法能力不足。</p>

<p>因为据说以后的同事大多是ACM选手，而本屌从来没搞过算法竞赛，而且知道的算法和数据结构都极为基础：像那些元胞自动机、斐波那契堆或是线段树这些高端数据结构压根只是能把它们的英文名称拼写出来，连用都没用过，所以心理忐忑的一逼。</p>

<p>为了不至于到时入职被鄙视的太惨烈，加上自己一贯的算法自卑症，本屌强制自己再次学习算法：</p>

<h2>Algorithms 4th</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-14.jpg"></p>

<p><a href="http://book.douban.com/subject/10432347/">Algorithms</a>是我重温算法的第一本书，尽管它实际就是一本<a href="http://book.douban.com/review/5348372/">数据结构的入门书</a>，但它确实适合当时已经快把算法忘光的本屌——不为学习，只为重温。</p>

<p>这本书最大的亮点在于它把Visualization和Formatting做到了极致——也许它不是最好的数据结构入门书，但它绝壁是我读过的排版最好的书，阅读体验爽的一逼；当然这本书的内容也不错，尤其是红黑树那一部分，我想不会有什么书会比此书讲的更明白。</p>

<h2>6.851 Advanced Data Structures</h2>

<p>Advanced Data Structures是MIT的高级数据结构教程，为什么会找到这个教程呢？因为Google Advanced Data Structures第一个出来的就是这货。</p>

<p>这门课包含各种让本屌世界观崩坏的奇诡数据结构和算法，它们包括但不限于：</p>

<ul>
<li>带”记忆”的数据结构（Data Structure with Persistence）。
van Emde Boas（逆天的插入，删除，前驱和后继时间复杂度）。
o(1)时间复杂度的的LCA、RMQ和LA解法。
奇幻的o(n)时间复杂度的Suffix Tree构建方法。
o(lglgn)的BST。
…</li>
</ul>

<p>总之高潮迭起，分分高能，唯一的不足就是没有把它们实现一圈。以后本屌一定找时间把它们一个个撸一遍。</p>

<h2>总结</h2>

<p>从接触算法到现在，大概七年：初学时推崇算法牛逼论，实习后鼓吹算法无用论，读研后再被现实打回算法牛逼论。</p>

<p>怎么这么像辩证法里的肯定到否定再到否定之否定。</p>

<p>现在来看，相当数量的鼓吹算法牛逼论的人其实不懂算法的重要性——如果你连用算法解决实际问题的经历都没有，那你如何可以证明算法很有用？而绝大多数鼓吹算法无用论的人不过是低水平码农的无病呻吟——他们从未碰到过需要用算法解决的难题，自然不知道算法有多重要。</p>

<p>Peter Norvig曾经写过一篇非常精彩的<a href="http://www.amazon.com/review/R403HR4VL71K8/">SICP书评</a>，我认为这里把SICP换成算法依然适用：
<blockquote>To use an analogy, if algorithms were about automobiles, it would be for the person who wants to know how cars work, how they are built, and how one might design fuel-efficient, safe, reliable vehicles for the 21st century. The people who hate algorithms are the ones who just want to know how to drive their car on the highway, just like everyone else.</blockquote></p>

<p>MIT教授<a href="http://erikdemaine.org/">Erik Demaine</a>则更为直接：
<blockquote>If you want to become a good programmer, you can spend 10 years programming, or spend 2 years programming and learning algorithms.</blockquote></p>

<p>总而言之，如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。</p>

<p>以上。</p>
</div>
                            <span class="post-date">2014-05-07 09:20:00</span>
                            <span class="post-tag">学习方法, 算法, 编程, learning, algorithms</span>
                        </div>
                    
                    <div class="pagination">
                        <ul>
                            
                                                           <li> <a class="round next" id="next" href="http://huliuqing.github.io/page/2">2</a></li>
                                                    </ul>
                    </div>
                </div><!--end/posts-->

			</div><!--end /contents-->

			<div class="footer">
				<div class="social span3">
					<h3>关注我</h3>
					<ul>
						<li><a class="glyph" href="" title=""><i class="icon-weibo"></i></a></li>
						<li><a class="glyph" href="" title="点点网博客"> 点点网</a></li>
						<li><a class="glyph" href="" title="柳公子的gmail邮箱"> stackoverflow</a></li>
					</ul>
				</div>				
				<div class="list span3">
					<h3>我的博客</h3>
					<ul>
			        	<li><a href="http://stackoverflow.com/users/1969039/liuqing-hu" title="柳公子在stackoverflow">stackoverflow</a></li>
			        	<li><a href="https://github.com/huliuqing" title="柳公子在github" >github</a></li>
			        	<li><a href="http://huliuqing.diandian.com" title="柳公子在点点博客">柳公子 - 点点网</a></li>
			        	<li><a href="http://weibo.com/focusliuqing" title="柳公子在新浪微博">柳公子 - weibo</a></li>
					              
					</ul>
				</div>	

				<div class="list span3">
					<h3>主题</h3>
					<ul>
						<li>社交图标 by <a href="https://github.com/lexrus/fontdiao" title="fontdiao"> fontdiao</a></li>
						<li>主题 by <a href="https://huliuqing.github.io" title="柳公子">柳公子</a></li>
					</ul>
				</div>
			</div><!--end/footer-->
		</div><!--end/wrapper-->
	</body>	
	
	<script type="text/javascript">
	var s=document.getElementById('search'), b=document.getElementById('sbutton');
	b.onclick = function() {
		if(s.value != '') {
			window.open("https://www.google.com.hk/#q=site:http://huliuqing.github.io "+s.value);
		} else {
			alert('请输入搜索内容');
		}
	}	
	</script>
	
	<script type="text/javascript">
	$(function () {
		$("pre").addClass("prettyprint linenums");
		prettyPrint();
	})
	</script>

</html>