<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[]]></title>
  <link href="/atom.xml" rel="self"/>
  <link href="/"/>
  <updated>2014-06-06T14:03:16+08:00</updated>
  <id>/</id>
  <generator uri="http://gitcafe.com/lizheming/pmblog">PMBlog</generator>

    <entry>
    <title type="html"><![CDATA[关于APC(alternative PHP cache)的那些事[译]]]></title>
    <link href="http://huliuqing.github.io/2014-05-30-everything-you-need-to-know-about-APC.html"/>
    <id>http://huliuqing.github.io/2014-05-30-everything-you-need-to-know-about-APC.html</id>
    <updated>2014-05-30T11:30:00+08:00</updated>
    <content type="html"><![CDATA[<blockquote>
    如未特别标明，文章均属原创。转载请注明出处 
    
by : 柳公子 <a href="http://huliuqing.github.io">http://huliuqing.github.io</a>
</blockquote>

<p>这是一篇翻译的文章。最近在使用APC(alternative PHP cache)扩展提升网站性能，虽然已运用到网站上，但是希望了解更多关于APC工作原理相关的知识。遂翻译了这篇文章<a href="http://linuxaria.com/howto/everything-you-need-to-know-about-apc-alternate-php-cache">Everything you need to know about APC (Alternate PHP cache)</a>。水平有限，有语句问题，邮我<code>liuqing.phper.cn@gmail.com</code>
你问我为什么要自己翻译？呵呵</p>

<h2>关于APC(alternative PHP cache)的那些事</h2>

<p>如果你是系统管理员，并且希望在Drupal，WordPress或自己开发的项目中提升PHP网站的性能，或许你就应该听说过Alternative PHP cache(简称 APC).</p>

<blockquote>
  <p>Alternative PHP cache是一款免费开源的opcode缓存系统，旨在提供免费开源强健的缓存和优化框架给PHP中间代码。</p>
</blockquote>

<p>通常我们通过php.net官网去了解APC的用法，但是我觉得仅仅通过它并不能更好的了解到如何使用APC提升性能。可以看看Guillermo Garron的<a href="http://www.garron.me/en/linux/apache-vs-nginx-php-fpm-varnish-apc-wordpress-performance.html">这篇文章</a>去了解一些使用apc之后的一些性能对比结果。</p>

<h2>APC如何工作</h2>

<p>首先我们需要知道，在Zend Engine中php是如何执行的。在Zend Engine中PHP脚本通常按照以下步骤运行。我们称之为“opcodes”。
    1.从文件系统中读取PHP代码，并放入内存
    2.语法分析：对内存中的php代码转换成句柄（tokens）和词典</p>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[Web缓存加速指南]]></title>
    <link href="http://huliuqing.github.io/2014-05-29-web-caching-guide.html"/>
    <id>http://huliuqing.github.io/2014-05-29-web-caching-guide.html</id>
    <updated>2014-05-29T09:00:00+08:00</updated>
    <content type="html"><![CDATA[<blockquote>
    如未特别标明，文章均属原创。转载请注明出处 
    
by : 柳公子 <a href="http://huliuqing.github.io">http://huliuqing.github.io</a>
</blockquote>

<h2>前端缓存优化加速的指南</h2>

<p>在这篇文章中，我会不定时的增加有关前端优化加速相关的好文章。</p>

<p><a href="http://www.cnblogs.com/lhb25/archive/2009/06/28/1512485.html">Web缓存技术相关简析</a></p>

<p><a href="http://www.chedong.com/tech/cache_docs.html">面向站长和网站管理员的Web缓存加速指南[翻译]</a></p>

<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html">Caching in HTTP[英文]</a></p>

<p><a href="http://browserdiet.com/en/">how to lose weight in the browser</a></p>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[如何创建简单的批处理（.bat）文件[译文]]]></title>
    <link href="http://huliuqing.github.io/2014-05-29-how-to-write-a-bat-file.html"/>
    <id>http://huliuqing.github.io/2014-05-29-how-to-write-a-bat-file.html</id>
    <updated>2014-05-29T09:00:00+08:00</updated>
    <content type="html"><![CDATA[<blockquote>
    如未特别标明，文章均属原创。转载请注明出处 
    
by : 柳公子 <a href="http://huliuqing.github.io">http://huliuqing.github.io</a>
</blockquote>

<p>想简单的学习批处理文件书写方法，于是翻译了这篇文章。原文<a href="http://www.makeuseof.com/tag/write-simple-batch-bat-file/">在这</a></p>

<h2>1.创建一个.bat文件</h2>

<p>在桌面创建一个文本文件，打开刚刚创建的文件。点解 file > save as，并输入批处理文件的文件名以.bat结尾。我创建的是testbat.bat</p>

<h2>2.快速掌握基本关键字</h2>

<p>如果你会使用命令行模式，那你更容易使用批处理文件,因为批处理文件和命令行模式使用同一种语言。我们仅仅需要通过批处理文件告诉命令行提示符需要做什么，而不是每次都打开命令行输入那些命令。这会为我们节省大量时间。只不过我们需要在批处理文件中添加一些逻辑处理（如简单的循环，条件语句等）</p>

<p>有如下7个简单的命令我们需要去熟悉，在命令行模式下这些命令是不区分大小写的</p>

<pre><code>TITLE - 设置命令提示窗口的窗口标题。默认为“cmd”

ECHO  - 批文件的输出语句。echo之后的所有词语都会在命令行中显示出来

ECHO OFF - 通常放在文件第一行。告诉命令行不要显示bat文件中的命令

PAUSE - 使用此关键字将会在命令行中输出“press any key to continue”,这样我们就可以有更多的时间去查看命令信息。这条语句在调试的时候会非常有用，因为它会终止批文件继续执行除非我们按下任意键。

CLS   - 清屏处理

IPCONFIG 打印输出当前的TCP/IP配置的设置值

ping     ping + ip地址，让我们知道电脑是否正常通讯
</code></pre>

<h2>3.快速掌握逻辑语句</h2>

<p>问题
  ① 通过ipconfig/all检测电脑网络设置
  ② 预留时间给用户阅读信息
  ③ ping google.com以检测我们的电脑是否联网了
  ④ 预留时间给用户阅读信息</p>

<h2>4.编写.bat文件</h2>

<pre><code>echo off    
chcp 65001
echo 通过bat文件，执行查看网络连接是否正常
ipconfig /all
pause
ping www.google.com
echo 所有执行通过
pause
</code></pre>

<h2>5.点击.bat文件运行</h2>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[memcache缓存处理简介]]></title>
    <link href="http://huliuqing.github.io/2014-05-27-install-memcache-in-php.html"/>
    <id>http://huliuqing.github.io/2014-05-27-install-memcache-in-php.html</id>
    <updated>2014-05-27T17:55:00+08:00</updated>
    <content type="html"><![CDATA[<blockquote>
  <p>如未特别标明，文章均属原创。转载请注明出处。by : 柳公子 <a href="http://huliuqing.github.io">http://huliuqing.github.io</a></p>
</blockquote>

<p>进行PHP开发工作3年，直到最近才更专注的去思考关于PHP项目性能问题（一直以来有去了解，但并未深入的去学习）。这篇文章简单讲解在windows平台下PHP开发中，安装和使用memcached缓存系统。</p>

<p>先来看看维基百科关于<a href="http://zh.wikipedia.org/wiki/Memcached" target="_blank">memcached</a>的解释：</p>

<blockquote>
  <p>memcached是一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发，但目前被许多网站使用。这是一套开放源代码软件，以BSD license授权发布。
  ...
  memcached的API使用三十二比特的循环冗余校验（CRC-32）计算键值后，将数据分散在不同的机器上。当表格满了以后，接下来新增的数据会以LRU机制替换掉。由于memcached通常只是当作高速缓存系统使用，所以使用memcached的应用程序在写回较慢的系统时（像是后端的数据库）需要额外的代码更新memcached内的数据。</p>
</blockquote>

<p>感觉很高端的样子，简单来说<code>memcached</code>是一套分布式的内存对象缓存系统，<code>Key/Value</code>值对以Hashmap方式缓存到内存中，以降低Web应用对数据库、文件读取的压力。</p>

<h2>memcached缓存系统组成</h2>

<p>一）  memcached服务守护程序</p>

<p>服务器守护程序是用C编写的，为客户端程序提供服务。<a href="http://code.jellycan.com/files/memcached-1.2.6-win32-bin.zip">点这里下载</a></p>

<p>二）  memcache客户端程序</p>

<p>客户端程序可以是任意语言编写的，通过memcached协议与守护程序通信。我们这下载PHP开发相关的版本。<a href="http://downloads.php.net/pierre/" target="_blank">到这里去下载</a></p>

<h2>memcached服务守护程序安装</h2>

<ol>
<li><p>1.下载memcached服务器程序,获取memcached.exe文件。<a href="http://code.jellycan.com/files/memcached-1.2.6-win32-bin.zip">点这里下载</a></p></li>
<li><p>2.进入命令行模式，使用命令安装memcached
c:/memcached/memcached.exe -d install</p></li>
<li><p>3.启动服务
c:/memcached/memcached.exe -d start</p></li>
</ol>

<p>默认情况下memcached服务器程序监听<code>11211</code>端口,并指定缓存使用的最大内存为<code>64MB</code>。</p>

<p>常用memcached选项参数</p>

<pre><code>-m 指定缓存所使用的最大内存容量，单位是Megabytes，默认是64MB
-u 只有以root身份运行时才指定该参数
-d 以daemon的形式运行
-l 指定监听的地址
-p 指定监听的TCP端口号，默认是11211

//"-d"参数更多选项值
-d install 安装memcached
-d uninstall 卸载memcached
-d start 启动memcached服务
-d restart 重启memcached服务
-d stop 停止memcached服务
-d shutdown 停止memcached服务
</code></pre>

<p>更多memcached选项参数，<a href="http://works.jinbuguo.com/man/memcached.html">点这里去了解</a></p>

<h2>memcache客户端安装</h2>

<p>如果使用XAMPP/WAMP集成开发环境，我们仅需下载php_memcache扩展程序。</p>

<ol>
<li><p>1.下载dll扩展程序（<a href="http://downloads.php.net/pierre/" target="_blank">到这里去下载</a>）,放于c:/xampp/php/ext/目录下。</p></li>
<li><p>2.开启扩展服务。
进入php.ini文件添加如下<code>extension=php_memcache.dll</code></p></li>
<li><p>3.重新启动XAMPP/WAMP</p></li>
</ol>

<h2>使用memcache缓存</h2>

<p>超简单示例：</p>

<pre><code>&lt;?php
$memcache = new Memcache;

$memcache-&gt;connect('127.0.0.1',11211);
$memcache-&gt;add('name','柳公子');
$name = $memcache-&gt;get('name');

echo $name;
</code></pre>

<p>进入官网手册，了解更多关于<a href="http://cn2.php.net/manual/zh/book.memcache.php">memcache</a>相关信息</p>

<h2>工具</h2>

<p><a href="http://www.junopen.com/memadmin/" target="_blank">memcache监控程序</a></p>

<p>参考资料：</p>

<p><a href="http://works.jinbuguo.com/man/memcached.html">memcache手册中文</a></p>

<p><a href="http://www.codeforest.net/how-to-install-memcached-on-windows-machine">How to install Memcached on Windows machine</a></p>

<p><a href="http://blog.csdn.net/poechant/article/details/7074257">Memcached基础及示例程序</a></p>

<p><a href="http://blog.csdn.net/poechant/article/details/7082115">Memcached配置参数初解</a></p>

<p><a href="http://zh.wikipedia.org/wiki/Memcached">维基百科：memcached</a></p>

<p><a href="http://baike.baidu.com/view/794242.htm">百度百科：memcached</a></p>

<p><a href="http://cn2.php.net/manual/zh/book.memcache.php">手册：memcached</a></p>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[如何优化PHP网站[译]]]></title>
    <link href="http://huliuqing.github.io/2014-05-26-translate-PHP-website-optimization.html"/>
    <id>http://huliuqing.github.io/2014-05-26-translate-PHP-website-optimization.html</id>
    <updated>2014-05-26T18:00:00+08:00</updated>
    <content type="html"><![CDATA[<p>转载请注明出处</p>

<p>这是一篇翻译自stackOverflow的文章，由于水平有限难免出错，如果您在阅读的时候发现了，请帮我更正。</p>

<h2>如何优化PHP网站</h2>

<p>问题如下（原文：<a href="http://stackoverflow.com/questions/8258567/php-website-optimization/8259911#8259911">PHP website Optimization</a>）：
    我拥有一个高访问量的网站，需要保证每个访问我站点的用户，都能够在最短的时间内显示出他们请求的页面。
    我通过Google搜索大量关于网站访问速度和优化方法的文章，并得出如下几个方案：</p>

<pre><code>    1. 对页面缓存
        通过对页面缓存，我可以让访问更加快速。但是如果我变更了页面的内容，我则必须把页面的内容从缓存中删除并重新对文件进行缓存。
    2. 页面静态化（把页面保存在磁盘中）
        通过页面静态化，我可以比较简单的对它进行维护。只是这样的话我必须每次访问它所在的目录来进行维护工作。
</code></pre>

<p>那么究竟如何才能够达到我想要的目的呢？</p>

<h2>------------------------------------------------------------------------------------------</h2>

<h2>来自Book Of Zeus的回答:</h2>

<p><a href="http://stackoverflow.com/a/8259911/3675700">Book Of Zeus</a></p>

<p>对于网站的性能来说，当我们需要获取静态或动态的内容时，减少访问数据库或文件系统的请求数，启用缓存（缓存页面或部分内容）是很重要的一个环节。</p>

<p>在运行动态内容的时候，我们可以使用加速PHP处理的软件：</p>

<p>（一）在这我推荐使用Alternative PHP Cache(<a href="http://php.net/manual/en/book.apc.php">通过手册了解更多关于APC信息</a>)。</p>

<p>推荐几篇关于APC的好文章给你：</p>

<ol>
<li><p>1.<a href="http://agilewebmasters.com/robert/what-is-the-best-php-accelerator-to-use/">What is the best PHP accelerator to use?
</a></p></li>
<li><p>2.<a href="http://blog.digitalstruct.com/2007/12/23/php-accelerators-apc-vs-zend-vs-xcache-with-zend-framework/">PHP Accelerators : APC vs Zend vs XCache with Zend Framework</a></p></li>
<li><p>3.<a href="http://blog.bodhizazen.net/linux/lighttpd-php-acceleration-benchmarks/">Lighttpd – PHP Acceleration Benchmarks</a></p></li>
</ol>

<p>（二）如果是缓存内容或整个页面的话，最好使用<a href="http://memcached.org">Memcached</a> 或 <a href="http://redis.io">Redis</a>进行缓存。</p>

<ol>
<li><p>1.<code>memcached</code>
一个高性能的分布式内存对象缓存开源系统。用于降低数据库负载，提升动态web程序的访问速度。memcached是通过把从数据库中返回的结果集、调用API返回的结果集或者呈现的页面。在内存中以键值对的形式进行缓存。</p></li>
<li><p>2.<code>Redis</code>
一款高性能键值对存储数据库开源项目。当值为字符，哈希表，列表，集合或排序集合时，它被视作一种数据结构服务程序。</p></li>
</ol>

<p>这两个(Memcached和Redis)项目都是用于缓存内容和变量的绝好工具。</p>

<p>推荐几篇有关Memcached和Redis的相关文章：</p>

<ol>
<li><p>1.<a href="http://trespams.com/2011/08/05/redis-vs-memcached-en/">Redis vs Memcached</a></p></li>
<li><p>2.<a href="On Redis, Memcached, Speed, Benchmarks and The Toilet">On Redis, Memcached, Speed, Benchmarks and The Toilet</a></p></li>
<li><p>3.<a href="http://systoilet.wordpress.com/2010/08/09/redis-vs-memcached/">Redis vs Memcached</a></p></li>
<li><p>4.<a href="http://dormando.livejournal.com/525147.html">Redis VS Memcached (slightly better bench)</a></p></li>
</ol>

<p>（三）使用varnish，nginx或G-Wan</p>

<ol>
<li><p>1.<code>Varnish</code>
一款专为有大量动态内容web网站设计的HTTP加速器。与其它HTTP加速器相比，如squid在客户端缓存;Apache则仅仅是服务器软件。Varnish则一开始就被设计成为HTTP加速器。</p></li>
<li><p>2.<code>Nginx</code>
是一款由俄罗斯程序员Igor Sysoev所开发轻量级的网页服务器、反向代理服务器以及电子邮件（IMAP/POP3）代理服务器。起初是供俄国大型的门户网站及搜索引擎Rambler（俄语：Рамблер）使用。此软件BSD-like协议下发行，可以在UNIX、GNU/Linux、BSD、Mac OS X、Solaris，以及Microsoft Windows等操作系统中运行</p></li>
<li><p>3.<code>g-wan</code>
C编写的Web服务器，比其它采用键值对存储的解决方案更加快速</p></li>
</ol>

<p>一些文章：   </p>

<ol>
<li><p>1.<a href="http://nbonvin.wordpress.com/2011/03/14/apache-vs-nginx-vs-varnish-vs-gwan/">Serving static files: a comparison between Apache, Nginx, Varnish and G-WAN</a></p></li>
<li><p>2.<a href="http://loadstorm.com/2011/05/web-server-performance-benchmarks/">Web Server Performance Benchmarks</a></p></li>
<li><p>3.<a href="http://www.garron.me/en/go2linux/nginx-varnish-vs-nginx-alone-compared.html">Nginx+Varnish compared to Nginx</a></p></li>
<li><p>4.<a href="http://cd34.com/blog/infrastructure/apache-varnish-nginx-and-lighttpd/">Apache, Varnish, nginx and lighttpd</a></p></li>
<li><p>5.<a href="http://www.wikivs.com/wiki/G-WAN_vs_Nginx">G-WAN vs Nginx</a></p></li>
</ol>

<p>(to be continued)</p>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[Apache Bench 工具介绍]]></title>
    <link href="http://huliuqing.github.io/2014-05-26-introduce-php-test-tool-ab.html"/>
    <id>http://huliuqing.github.io/2014-05-26-introduce-php-test-tool-ab.html</id>
    <updated>2014-05-26T14:51:52+08:00</updated>
    <content type="html"><![CDATA[<blockquote>
  <p>如未特别标明，文章均属原创。转载请注明出处 
      by : 柳公子 <a href="http://huliuqing.github.io ">http://huliuqing.github.io </a></p>
</blockquote>

<p>apache benchmark（以下简称ab）是一款基准测试工具,用于描绘当前安装的apache服务器的执行性能,是apache安装的一部分。用户可以模拟对特定URL的任意数量请求来对Web服务器进行负载测试，观察你的apache服务器每秒可以处理多少请求。</p>

<p>ab工具提供以下信息：</p>

<ul>
<li>传输的总大小</li>
<li>Web服务器在模拟流量下每秒可以支持的请求总数</li>
<li>完成一个请求所花费的最长时间</li>
<li>完成一个请求所花费的最少时间</li>
</ul>

<h2>ab语法</h2>

<pre><code>ab
    [-A auth-username:password]
    [-c concurrency]
    [-C cookie-name=value]
    [-d]
    [-e csv-file]
    [-g gnuplot-file]
    [-h]
    [-H custom-header]
    [-i]
    [-k]
    [-n requests]
    [-p POST-file]
    [-P proxy-auth-username:password]
    [-q]
    [-s]
    [-S]
    [-t timelimit]
    [-T content-type]
    [-v verbosity]
    [-V]
    [-w]
    [-x &lt;table&gt;-attributes]
    [-X proxy[:port]]
    [-y &lt;tr&gt;-attributes]
    [-z &lt;td&gt;-attributes]
[http://]hostname[:port]/path
</code></pre>

<h2>ab选项标记</h2>

<pre><code>-A auth-username:password 
向服务器提供基本认证信息。用户名和密码之间由一个":"隔开，并将被以base64编码形式发送。无论
服务器是否需要(即是否发送了401认证需求代码)，此字符串都会被发送。 

-c concurrency 
一次产生的请求个数。默认设置为1。 

-C cookie-name=value 
对请求附加一个"Cookie:"头行。其典型形式是 name=value 的一个参数对。此参数可以重复。

-d 
不显示"percentage served within XX [ms] table"消息(为以前的版本提供支持)。 

-e csv-file 
产生一个逗号分隔(CSV)文件，该文件包含基准测试的运行结果(其中包含了处理每个相应
百分比[Percentage served]请求(从1%到100%)所需要的相应百分比时间[Time in ms](以微
秒为单位))。由于这种格式已经"二进制化"，所以比"gnuplot"格式更有用。 

-g gnuplot-file 
把所有测试结果写入一个"gnuplot"或者TSV(以Tab分隔)文件。此文件可以方便地导入到 Gnuplot,
IDL, Mathematica, Excel中。其中的第一行为标题。 

-h 
显示要用于ab的选项列表。 

-H custom-header 
对请求附加额外的头信息。此参数的典型形式是一个有效的头信息行，其中包含了以冒号分隔的字段
和值(如："Accept-Encoding: zip/zop;8bit")。 

-i 
执行HEAD请求，而不是默认的GET请求 。 

-k 
启用KeepAlive功能，即在一个HTTP会话中执行多个请求。默认不启用KeepAlive功能。 

-n requests 
在测试会话中所执行的请求个数。默认仅执行一个请求，此时其结果不具有意义，n值最大为50000。

-p POST-file 
包含了POST数据的文件。 

-P proxy-auth-username:password 
对一个中转代理提供基本认证信息。用户名和密码由一个":"隔开，并将被以base64编码形式发送。
无论服务器是否需要(即是否发送了407代理认证需求代码)，此字符串都会被发送。 

-q 
如果处理的请求数大于150，ab每处理大约10%或者100个请求时，会在stderr输出一个进度计数。此 
-q 标记可以屏蔽这些信息。

-s 
用于编译中(ab -h 会告诉你)使用了SSL的受保护的https ，而不是http协议的时候。此功能是实验性的，最好不要用。 

-S 
不显示中值和标准偏差值，而且在均值和中值为标准偏差值的1到2倍时，也不显示警告或出错信息。
默认时，会显示最小值/均值/最大值等数值。(为以前的版本提供支持) 

-t timelimit 
测试所进行的最大秒数。内部隐含值是"-n 50000"。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。

-T content-type 
POST数据时所使用的"Content-type"头信息。 

-v verbosity 
设置显示信息的详细程度，4或更大值会显示头信息，3或更大值可以显示响应代码(404，200等)，2或更大值可以显示警告和其他信息。 

-V 
显示版本号并退出。 

-w 
以HTML表格形式输出结果。默认时，它是白色背景的两列宽度的一张表。 

-x &lt;table&gt;-attributes 
设置&lt;table&gt;属性的字符串。此属性被填入&lt;table 这里 &gt; 。 

-X proxy[:port] 
对请求使用代理服务器。 

-y &lt;tr&gt;-attributes 
设置&lt;tr&gt;属性的字符串。 

-z &lt;td&gt;-attributes 
设置&lt;td&gt;属性的字符串。 
</code></pre>

<h2>运行ab工具</h2>

<p>现在我们要运行ab工具来对http://www.github.com来进行基准测试。
运行如下命令：</p>

<p>ab -n 1 http://www.github.com/</p>

<p>输出结果如下</p>

<pre><code>Server Software:
Server Hostname:        www.github.com
Server Port:            80
#服务器信息


Document Path:          /
Document Length:        0 bytes
#文档信息


Concurrency Level:      1
Time taken for tests:   1.651 seconds
Complete requests:      1
Failed requests:        0
Write errors:           0
Non-2xx responses:      1
Total transferred:      107 bytes
HTML transferred:       0 bytes
Requests per second:    0.61 [#/sec] (mean)
Time per request:       1650.709 [ms] (mean)
Time per request:       1650.709 [ms] (mean, across all concurrent requests)
Transfer rate:          0.06 [Kbytes/sec] received
#连接信息


Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:      862  862   0.0    862     862
Processing:   788  788   0.0    788     788
Waiting:      788  788   0.0    788     788
Total:       1650 1650   0.0   1650    1650
#连接指标分类
</code></pre>

<h2>1. 服务器信息部分</h2>

<p>一般我们的Web服务器软件会是apache，那么在Server Software : 中会显示 apache : 。
但是由于Web管理员使用安全措施，该字段可能返回其它内容或什么也不返回（如示例）</p>

<pre><code>Server Hostname : 测试主机名
Server Post : 测试主机的Web服务器监听端口号
</code></pre>

<h2>2. 脚本信息部分</h2>

<p>包含基准测试主机的Web文档的信息内容</p>

<pre><code>Document Path :  包含测试请求的文档
Document Length : 包含所有HTML 、CSS、JS、图像及其响应的其它数据的字节数总和
</code></pre>

<h2>3. 链接信息部分</h2>

<p>连接数据包含基准测试信息最核心的反馈信息。
其中最需要关心的内容部分：</p>

<pre><code>    HTML transferred    整个模拟测试中传输的内容正文总大小
    Requests per second 每秒支持的请求数
    Time per request    满足一个请求需要花费的总时间
</code></pre>

<p>优化目标：减少HTML transferred 大小，提高Requests per second并降低Time per request值</p>

<h2>4. 连接指标分类</h2>

<p>在这一部分我们主要关注Total项目中的min : ,max : 列</p>

<pre><code>min : 请求所花费的最短时间
man : 请求所花费的最长时间
</code></pre>

<h2>参考资料</h2>

<p><a href="http://apache.chinahtml.com/programs/ab.html">apache 中文手册</a> </p>

<p>未完待续</p>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[详解PHP中对象属性遍历]]></title>
    <link href="http://huliuqing.github.io/2014-05-15-analyze-object-iterator-in-php.html"/>
    <id>http://huliuqing.github.io/2014-05-15-analyze-object-iterator-in-php.html</id>
    <updated>2014-05-15T10:41:30+08:00</updated>
    <content type="html"><![CDATA[<h2>对象迭代</h2>

<p><blockquote>
    如未特别标明，文章均属原创。转载请注明出处 </p>

<p>by : 柳公子 <a href="http://huliuqing.github.io">http://huliuqing.github.io</a>
</blockquote></p>

<p>php官网手册对于<a href="http://www.php.net/manual/zh/language.oop5.iterations.php" target="_blank">遍历对象</a>解释如下：
<blockquote>PHP 5 提供了一种定义对象的方法使其可以通过单元列表来遍历，例如用 foreach 语句。默认情况下，所有可见属性都将被用于遍历。 </blockquote></p>

<p>不过使用简单的foreach遍历对象，仅仅能够遍历出对象实例中可见（public)属性的值。</p>

<p>foreach是如何实现对对象进行遍历的呢？</p>

<p>我们的鸟哥在<a href="http://www.laruence.com/2008/10/31/574.html" >关于一笔试题(Iterator模式) </a>一文中分享过foreach源码实现。这边我就拿来主义了：</p>

<pre><code>switch (zend_iterator_unwrap(array, &amp;iter TSRMLS_CC)) {
    default:
        case ZEND_ITER_INVALID:
               .....
               break
        case ZEND_ITER_PLAIN_OBJECT: {
                ......
            break;
     case ZEND_ITER_PLAIN_ARRAY:
            .....
            break;

        case ZEND_ITER_OBJECT:
            ......
            break;
}
</code></pre>

<p>具体如何使用<code>foreach</code>遍历对象，查看示例：</p>

<pre><code>&lt;?php

class Student{
    private $_identityCard = '360401190001011018';
    public  $_name = '三丰';
    public  $_age  = 800;

    protected $_bloodType = 'O';

    public function __construct(){}
}

$s = new Student();

foreach($s as $key =&gt; $v){
    echo 'key ',$key ,' val ',$v ,'&lt;/br&gt;';
}

//输出
key :_name val 三丰
key :_age val 800
</code></pre>

<p>从输出的结果来看，实例化对象的所有可见(<code>public</code>)属性都给遍历输出出来了。</p>

<p>但是，当我们需要遍历那些非可见对象属性，明显简单的使用<code>foreach</code>遍历对象就不够用了。</p>

<p>好在PHP中有提供内置遍历接口<code>Iterator</code> 和 <code>IteratorAggregate</code>完成对象的遍历工作。
关于Iterator与IteratorAggregate接口如下：</p>

<pre><code>Iterator extends Traversable {
    /* 方法 */
    abstract public mixed current ( void )//返回当前元素。 
    abstract public scalar key ( void )   //返回当前元素的键
    abstract public void next ( void )    //移动当前位置到下一个元素
    abstract public void rewind ( void )  //返回到迭代器的第一个元素
    abstract public boolean valid ( void )//此方法在 Iterator::rewind() 和 Iterator::next()
                                          //方法之后被调用以此用来检查当前位置是否有效
}

IteratorAggregate extends Traversable {
    /* 方法 */
    abstract public Traversable getIterator ( void )//返回一个外部迭代器
}
</code></pre>

<p>我们可以通过实现这两个迭代器接口，定义自己的对象遍历规则</p>

<p>1、通过实现IteratorAggregate接口，完成对象属性遍历</p>

<p>我们只需要实现IteratorAggregate中getIterator()方法完成遍历。</p>

<pre><code>class Kungfu implements IteratorAggregate{
    public $_name='飞鸿';
    public $_age = 121;

    protected $_bloodType = 'O';
    private $_isMarried = true;

    public function __construct(){}

    public function getIterator(){
        $members = get_class_vars(__CLASS__);

        return new ArrayIterator($members);
    }
}


$k = new Kungfu();

foreach($k as $key =&gt; $v){
    echo 'key ',$key ,' val ',$v ,'&lt;/br&gt;';
}
/*
    key _name val 飞鸿
    key _age val 121
    key _bloodType val O
    key _isMarried val 1
*/
</code></pre>

<p>2、通过实现Iterator接口，完成对象属性遍历</p>

<p>相对于<code>IteratorAggregate</code>而言，<code>Iterator</code>接口实现起来稍微麻烦一些，需要在实现类中实现所有5个抽象方法。</p>

<p>不过如果我们需要对迭代的对象，进行具体控制的话，使用<code>Iterator</code>的话则更合适。</p>

<pre><code>class Language implements Iterator{
    private $_lang;
    private $_counter=0;

    public function __construct(){      
        $this-&gt;_lang = explode(',', 'PHP,C++,C,GO,JAVA,JAVASCRIPT,RUBY,Node.js');
    }

    public function rewind(){
        $this-&gt;_counter = 0;
    }

    public function current(){
        //当编程语言的值为JAVA时，返回空
        if($this-&gt;_lang[$this-&gt;_counter] == 'JAVA'){
            return null;
        }
        return $this-&gt;_lang[$this-&gt;_counter];
    }

    public function valid(){
        return isset( $this-&gt;_lang[$this-&gt;_counter]);
    }

    public function next(){
        ++$this-&gt;_counter;
    }
    public function key(){
        return $this-&gt;_counter;
    }
}

$m = new Language();

foreach($m as $key =&gt; $v){
    echo 'key ',$key ,' val ',$v ,'&lt;/br&gt;';
}

//结果输出
key 0 val PHP
key 1 val C++
key 2 val C
key 3 val GO
key 4 val 
key 5 val JAVASCRIPT
key 6 val RUBY
key 7 val Node.js
</code></pre>

<p>接口<code>Iterator</code>中抽象方法的执行顺序如下图所示：
<img src="http://huliuqing.github.io/images/post-source/2014-05-analyze-object-iterator-in-php.png" title="Iterator抽象方法调用顺序"></img></p>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[我的算法学习之路 - [转载]]]></title>
    <link href="http://huliuqing.github.io/2014-05-07-how-to-learning-algorithm-reprint.html"/>
    <id>http://huliuqing.github.io/2014-05-07-how-to-learning-algorithm-reprint.html</id>
    <updated>2014-05-07T09:20:00+08:00</updated>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://zh.lucida.me/blog/on-learning-algorithms/" target="_blank">我的算法学习之路</a></p>

<p>原文作者：<a href="http://zh.lucida.me/blog/on-learning-algorithms/" target="_blank">Lucida</a></p>

<h2>这篇文章讲了什么？</h2>

<ul>
<li><p>我这些年学习数据结构和算法的总结。</p></li>
<li><p>一些不错的算法书籍和教程。</p></li>
<li><p>算法的重要性。</p></li>
</ul>

<h2>初学 ##</h2>

<p>第一次接触数据结构是在大二下学期的数据结构课程。然而这门课程并没有让我入门——当时自己正忙于倒卖各种MP3和耳机，对于这些课程根本就不屑一顾——反正最后考试划个重点也能过，于是这门整个计算机专业本科最重要的课程就被傻逼的我直接忽略过去了。</p>

<p>直到大三我才反应过来以后还要找工作——而且大二的折腾证明了我并没有什么商业才能，以后还是得靠码代码混饭吃，我当时惊恐的发现自己对编程序几乎一无所知，于是我给自己制订了一个类似于建国初期五年计划的读书成长计划，其中包括C语言基础、数据结构以及计算机网络等方面的书籍。</p>

<p>读书计划的第一步是选择书籍，我曾向当时我觉得很牛的”学长”和”大神”请教应该读哪些算法书籍，”学长”们均推荐算法导论，还有几个”大神”推荐计算机程序设计艺术（现在我疑心他们是否翻过这些书），草草的翻了下这两本书发现实在看不懂，但幸运的是我在无意中发现了豆瓣这个神奇的网站，里面有很多质量不错的书评，于是我就把评价很高而且看上去不那么吓人的计算机书籍都买了下来——事实证明豆瓣要比这些”学长”或是”大神”靠谱的多得多。</p>

<h2>数据结构与算法分析——C语言描述</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-1.jpg"></p>

<p><a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我学习数据结构的第一本书：当时有很多地方看不懂，于是做记号反复看；代码看不明白，于是抄到本子上反复研读；一些算法想不通，就把它所有的中间状态全画出来然后反复推演。事实证明尽管这种学习方法看起来傻逼而且效率很低，但对于当时同样傻逼的我却效果不错——傻人用傻办法嘛，而且这本书的课后题大多都是经典的面试题目，以至于日后我看到<a href="http://book.douban.com/subject/3004255/">编程之美</a>的第一反应就是这货的题目不全是抄别人的么。</p>

<p>至今记得，这本书为了说明算法是多么重要，在开篇就拿最大子序列和作为例子，一路把复杂度从O(N3)杀到O(N2)再到O(NlgN)最后到O(N)，当时内心真的是景仰之情=如滔滔江水连绵不绝，尼玛为何可以这么屌，</p>

<p>此外，我当时还把这本书里图算法之前的数据结构全手打了一遍，后来找实习还颇为自得的把这件事放到简历里，现在想想真是傻逼无极限。</p>

<p>凭借这个读书成长计划中学到的知识，我总算比较顺利的找到了一份实习工作，这是后话。</p>

<h2>入门</h2>

<p>我的实习并没有用到什么算法（现在看来就是不停的堆砌已有的API，编写一堆自己都不知道对不对的代码而已），在发现身边的人工作了几年却还在和我做同样的事情之后，我开始越来越不安。尽管当时我对自己没什么规划，但我清楚这绝壁不是我想做的工作。</p>

<h2>微软的梦工厂</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-2.jpg"></p>

<p>在这个摇摆不定的时刻，<a href="http://book.douban.com/subject/3238803/">微软的梦工场</a>成了压倒骆驼的最后一支稻草，这本书对微软亚洲研究院的描写让我下定了”找工作就要这样的公司”的决心，然而我又悲观的发现无论是以我当时的能力还是文凭，都无法达到微软亚研院的要求，矛盾之下，我彻底推翻了自己”毕业就工作”的想法，辞掉实习，准备考研。</p>

<p>考研的细节无需赘述，但至今仍清楚的记得自己在复试时惊奇且激动的发现北航宿舍对面就是微软西格玛大厦，那种离理想又进了一步的感觉简直爽到爆。</p>

<h2>算法设计与分析</h2>

<p>我的研究生生涯绝对是一个反面典型——翘课，实习，写水论文，做水研究，但有一点我颇为自得——从头到尾认真听了韩军教授的算法设计与分析课程。</p>

<p>韩军给我印象最深的有两点：课堂休息时跑到外面和几个学生借火抽烟；讲解算法时的犀利和毫不含糊。</p>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-3.jpg"></p>

<p>尽管韩军从来没有主动提及，但我敢肯定<a href="http://book.douban.com/subject/3238803/">算法设计与分析基础</a>就是他算法课程事实上的（de-facto）教材，因为他的课程结构几乎和这本书的组织结构一模一样。</p>

<p>如果<a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我的数据结构启蒙，那么韩军的课程和<a href="http://book.douban.com/subject/3238803/">算法设计与分析基础</a>就是我的算法启蒙，结合课程和书籍，我一一理解并掌握了复杂度分析、分治、减治、变治、动态规划和回溯这些简单但强大的算法工具</p>

<h2>算法引论</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-4.jpg"></p>

<p><a href="http://book.douban.com/subject/4178907/">算法导论</a>是我这时无意中读到的另一本算法书，和普通的算法书不同，这本书从创造性的角度出发——如果说算法导论讲的是有哪些算法，那么算法引论讲的就是如何创造算法。结合前面的<a href="http://book.douban.com/subject/3238803/">算法设计与分析基础</a>，这本书把我能解决的算法问题数量扩大了一个数量级。</p>

<p>之后，在机缘巧合下，我进入微软亚洲工程院实习，离理想又近了一步，自我感觉无限牛逼。</p>

<h2>巩固</h2>

<p>在微软工程院的实习是我研究生阶段的一个非常非常非常重要的转折点：</p>

<ul>
<li>做出了一个还说的过去的小项目。</li>
<li>期间百度实习面试受挫，痛定思痛之下阅读了大量的程序设计书。</li>
<li>微软的实习经历成为了我之后简历上为数不多的亮点之一（本屌一没成绩，二没论文，三没ACM）。</li>
</ul>

<p>这里就不说1和3了（和本文题目不搭边），重点说说2。</p>

<p>由于当时组内没有特别多的项目，我负责的那一小块又提前搞定了，mentor便很慷慨的扔给我一个Kinect和一部Windows Phone让我研究，研究嘛，自然就没有什么deadline，于是我就很鸡贼的把时间三七开：七分倒腾Windows Phone，三分看书&amp;经典论文。</p>

<p>然而一件事打断了这段安逸的生活——</p>

<h2>百度实习面试</h2>

<p>基友在人人发百度实习内推贴，当时自我感觉牛逼闪闪放光芒，于是就抱着看看国内IT环境+虐虐面试官的变态心理投了简历，结果在第一面就自己的师兄爆出翔：他让我写一个stof（字符串转浮点数），我磨磨唧唧半天也没写出完整实现，之后回到宿舍赶快写了一个版本发到师兄的邮箱，结果对方压根没鸟我。</p>

<p>这件事对我产生了很大的震动——</p>

<ul>
<li><p>原来自己连百度实习面试都过不去。</p></li>
<li><p>原来自己还是一个编程弱逼。</p></li>
<li><p>原来自己还是一个算法菜逼。</p></li>
</ul>

<p>痛定思痛，我开始了第二个”五年计划”，三七开的时间分配变成了七三开：七分看书，三分WP。而这一阶段的重点从原理（Principle）变成了实现（Implementation）——Talk is cheap, show me the code.</p>

<h2>Elements of Programming</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-5.jpg"></p>

<p>由于一直觉得名字里带”Elements of”的都是酷炫叼炸天的书，所以我几乎是毫不犹豫的买了这本<a href="http://book.douban.com/subject/3802826/">Elements of Programming</a>，事实上这本书里的代码（或者说STL的代码）确实是：快，狠，准，古龙高手三要素全齐。</p>

<h2>C Interfaces and Implementation</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-6.jpg"></p>

<p>百度面试被爆出翔的经历让我意识到另一个问题，绝大多数公司面试时都需要在纸上写C代码，而我自己却很少用C（多数情况用C#），考虑到自己还没牛逼到能让公司改变面试流程的地步，我需要提升自己编写C代码的能力（哪怕只是为了面试）。一顿Google之后，我锁定了<a href="http://book.douban.com/subject/1826926/">C Interfaces and Implementation</a>——另一本关于如何写出狂炫酷帅叼炸天的C代码的奇书，这里套用下Amazon的评论：Probably the best advanced C book in existance。</p>

<p>严格来说上面两本书都不是传统的算法书，因为它们侧重的都不是算法，而是经典算法的具体实现（Implementation），然而这正是我所需要的：因为算法的原理我能说明白，但要给出优雅正确简练的实现我就傻逼了，哪怕是stof这种简单到爆的”算法”。</p>

<p>依然是以前的傻逼学习方法：反复研读+一遍又一遍的把代码抄写到本子上，艰难的完成了这两本书后，又读了相当数量的编程实践（Programming Practice）书籍，自我感觉编程能力又大幅提升，此外获得新技能——纸上编码。这也成为了我之后找工作面试的三板斧之一。</p>

<h2>应用</h2>

<p>说老实话，自从本科实习之后，我就一直觉得算法除了面试时能用用，其它基本用不上，甚至还写了一篇当时颇为自得现在读起来极为傻逼的文章来黑那些动不动就”基础”或”内功”的所谓”大牛”们，这里摘取一段现在看起来很傻逼但当时却觉得是真理的文字：</p>

<blockquote>所以那些动则就扯什么算法啊基础啊内功啊所谓的大牛们，请闭上你的嘴，条条大道通罗马。算法并不是编程的前提条件，数学也不会阻碍一个人成为优秀的程序员。至少在我看来，什么算法基础内功都是唬人的玩意，多编点能用的实用的程序才是王道，当然如果你是一个pure theorist的话就当我什么都没说好了。</blockquote>

<p>然而有意思的是，写了这篇<a href="http://book.douban.com/review/3733680/" target="_black">文章</a>没多久，鼓吹算法无用论的我自己做的几个大大小小的项目全部用到了算法——我疑心是上天在有意抽我的脸</p>

<h2>LL(k)</h2>

<p>我在微软实习的第一个项目做的是代码覆盖率分析——计算T-SQL存储过程的<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B">代码覆盖率</a>。</p>

<p>简单的看了下SQL Server相关的文档，我很快发现SQL Reporting Service可以记录T-SQL的执行语句及行号，于是行覆盖（line coverage）搞定，但老大说行覆盖太naive，我们需要更实际的块覆盖（block coverage）。</p>

<p>阅读了块覆盖的定义后，我发现我需要对T-SQL进行语法分析，在没有找到一个好用的T-SQL Parser的情况下，只能自己动手搞一个：</p>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-7.jpg"></p>

<p>比较奇诡的是，做这个项目时当时我刚好把ANTLR作者的<a href="http://book.douban.com/subject/4030327/">Language Implementation Patterns</a>看了一半，什么LL(k)啊Packrat啊AST Walker的概念啊正热乎着呢。</p>

<p>于是，自己自己就照着T-SQL的官方EBNF，三下五除二撸了一个T-SQL存储过程的LL(k) Parser，把代码转换成AST，然后用一个External AST Walker生成代码块覆盖的HTML报表，全部过程一周不到。</p>

<p>老大自然是很满意——我疑心他的原计划是花两三个月来完成这个项目，因为这个项目之后的两个月我都没什么活干，天天悠哉游哉。</p>

<h2>拼音索引</h2>

<p>比如说输入中国：
    <a href="">sorry 图片未找到</a></p>

<p>同样，输入拼音也应给出提示：<br />
    <a href="">sorry 图片未找到</a></p>

<p>中文匹配这个简单，但拼音匹配就得花时间想想了——懒得造轮子的我第一时间找到了微软的拼音库，但接下来我就发现微软这个鸟库在手机上跑不动，研究了下发现WP7对Dictionary的items数量有限制，貌似是7000还是8000个item就会崩盘，而标准汉字则有两万多个，尼玛。</p>

<p>痛骂MS坑爹+汉字坑爹之余，还是得自己撸一个库出来：</p>

<ul>
<li>首先把那两万个汉字搞了出来，排序，然后弄成一个超长的字符串。</li>
<li>接下来用Int16索引了汉字所有的拼音（貌似500多个）。</li>
<li>再接下来用Int64建立汉字和拼音的关联——汉字有多音字，所以需要把多个拼音pack到一个Int64里，这个简单，位操作就搞定。</li>
<li>最后用二分+位移Unpack，直接做到从汉字到拼音的检索。</li>
<li>后来小测了下性能，速度是MS原来那个库的五十倍有余，而代码量只有336行。</li>
</ul>

<p>用户很happy——因为我捎带把他没想到的多音字都搞定了，而且流畅的一逼。</p>

<p>我也很happy，因为没想到自己写的库居然比MS的还要快几十倍，同时小十几倍。</p>

<p>从这个事情之后我变得特别理解那些造轮子的人——你要想想，如果你需要一个飞机轮子但市场上只有自行车轮子而且老板还催着你交工，你能怎么搞。</p>

<h2>快速字符串匹配</h2>

<p>前面提到在微软实习时老大扔给我一个Windows Phone让我研究下，我当时玩了玩就觉着不太对劲，找联系人太麻烦。</p>

<p>比如说找”张晓明”，WP只支持定位到Z分类下——这意味着我需要在Z分类下的七十多个联系人（姓张的姓赵的姓钟的等等）里面线性寻找，每次我都需要滑动四五秒才能找到这个张姓少年。
<a href="">sorry 图片未找到</a></p>

<p>这TMD也太傻逼了，本屌三年前的老破NOKIA都支持首字母定位，996->ZXM->张晓明，直接搞定，尼玛一个新时代Windows Phone居然会弱到这个程度。</p>

<p>搜了一下发现没有好用的拨号程序，于是本屌就直接撸了一个支持首字母匹配的拨号程序出来扔到WP论坛里。</p>

<p>结果马上就有各种问题出现——最主要的反映是速度太慢，一些用户甚至反馈按键有时要半秒才有反应。本屌问了下他的通讯录大小：大概3000多人。</p>

<p><a href="">sorry 图片未找到</a></p>

<p>吐槽怎么会有这么奇葩的通讯录之余，我意识到自己的字符串匹配算法存在严重的性能问题：读取所有人的姓名计算出拼音，然后一个个的匹配——结果如果联系人数量太多的话，速度必然拙计。</p>

<p>于是我就开始苦思冥想有没有一个能够同时搜索多个字符串的高端算法，以至于那两天坐地铁都在嘟囔怎么才能把这个应用搞的快一些。</p>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-8.jpg"></p>

<p>最终还是在<a href="http://book.douban.com/subject/1765938/">Algorithms on Strings, Trees and Sequences</a>里找到了答案——确实有能够同时搜索多个字符串的方法：Tries，而且这本书还用足足一章来讲怎么弄Multiple string comparison，看得我当时高潮迭起，直呼过瘾。</p>

<p>具体细节不多说，总之换了算法之后，匹配速度快了大约九十多倍，而且代码还短了几十行。哪怕是有10000个联系人，也能在0.1秒内搞定，速度瓶颈就这样愉快的被算法搞定。</p>

<h2>Writing Efficient Programs</h2>

<p>之后又做了若干个项目，多多少少都用到了”自制”的算法或数据结构，最奇诡的一次是写一个电子书阅读器里的分页，我照着模拟退火（Simulated Annealing）的原理写了一个快速分页算法，事实上这个算法确实很快——但问题是我都不知道为啥它会这么快。</p>

<p>总之，算法是一种将有限计算资源发挥到极致的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀（因为算法不要钱嘛！要不还得换CPU买SSD升级RAM，肉疼啊！！）。一些人会认为这种说法是有问题，因为编写新算法的人力成本有时比增加硬件的成本还要高——但别忘了增加硬件提升效率也是建立在算法是Scalable的基础上——说白了还是得撸算法。</p>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-9.jpg"></p>

<p>说到优化这里顺带提一下<a href="http://book.douban.com/subject/1768600/">Writing Efficient Programs</a>——很难找到一本讲代码优化的书（我疑心是自从Knuth说了过早优化是万恶之源之后没人敢写，万恶之源嘛，写它干毛），注意这本书讲的是代码优化——在不改变架构、算法以及硬件的前提之下进行的优化。尽管书中的一些诸如变量复用或是循环展开的trick已经过时，但总体仍不失为一本好书。</p>

<h2>提高</h2>

<p>实习实习着就到了研二暑假，接下来就是求职季。</p>

<p>求职季时我有一种莫名的复仇感——尼玛之前百度实习面试老子被你们黑的漫天飞翔，这回求职老子要把你们一个个黑回来，尼玛。</p>

<p>现在回想当时的心理实属傻逼+幼稚，但这种黑暗心理也起了一定的积极作用：我丝毫不敢有任何怠慢，以至于在5月份底我就开始准备求职笔试面试，比身边的同学早了两个月不止。</p>

<p>我没有像身边的同学那般刷题——而是继续看书抄代码学算法，因为我认为那些难得离谱的题面试官也不会问——事实上也是如此。</p>

<h2>Algorithm Design Manual</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-10.jpg"></p>

<p>因为很多Coding Interview的论坛都提到这本<a href="http://book.douban.com/subject/3872383/">红皮书</a>，我也跟风搞了一本。事实证明，仅仅是关于Backtrack Template那部分的描述就足以值回书价，更不用说它的Heuristics和课后题。</p>

<h2>编程珠玑&amp;更多的编程珠玑</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-11.jpg"></p>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-12.jpg"></p>

<p>这两本书就不用多介绍，<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>和<a href="http://book.douban.com/subject/1944826/">更多的编程珠玑</a>，没听说过这两本书请自行面壁。前者偏算法理论，后者偏算法轶事，前者提升能力，后者增长谈资，都值得一读。</p>

<h2>The Science of Programming</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-13.jpg"></p>

<p>读到<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>里面关于Binary Search的正确性证明时我大呼过瘾，原来程序的正确性也是可以推导的，然后我就在那一章的引用里发现David Gries的<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>。看名字就觉得很厉害，直接搞了一本开撸。</p>

<p>不愧为编程珠玑引用的书籍，撸完The Science of Programming之后，本屌获得了证明简单代码段的正确性这个技能——求职面试三板斧之二。</p>

<p>证明简单代码段的正确性是一个很神奇的技能——因为面试时大多数公司都会要求在纸上写一段代码，然后面试官检查这段代码，如果你能够自己证明自己写的代码是正确的，面试官还能挑剔什么呢？</p>

<p>之后就是各种面试，详情见之前的博客，总之就是项目经历、纸上代码加正确性证明这三板斧，摧枯拉朽。</p>

<h2>进化</h2>

<p>求职毕业季之后就是各种Happy，Happy过后本屌发现即将面临另一个问题：算法能力不足。</p>

<p>因为据说以后的同事大多是ACM选手，而本屌从来没搞过算法竞赛，而且知道的算法和数据结构都极为基础：像那些元胞自动机、斐波那契堆或是线段树这些高端数据结构压根只是能把它们的英文名称拼写出来，连用都没用过，所以心理忐忑的一逼。</p>

<p>为了不至于到时入职被鄙视的太惨烈，加上自己一贯的算法自卑症，本屌强制自己再次学习算法：</p>

<h2>Algorithms 4th</h2>

<p><img src="http://huliuqing.github.io/images/post-source/2014-05-how-to-learning-algorithm-reprint-14.jpg"></p>

<p><a href="http://book.douban.com/subject/10432347/">Algorithms</a>是我重温算法的第一本书，尽管它实际就是一本<a href="http://book.douban.com/review/5348372/">数据结构的入门书</a>，但它确实适合当时已经快把算法忘光的本屌——不为学习，只为重温。</p>

<p>这本书最大的亮点在于它把Visualization和Formatting做到了极致——也许它不是最好的数据结构入门书，但它绝壁是我读过的排版最好的书，阅读体验爽的一逼；当然这本书的内容也不错，尤其是红黑树那一部分，我想不会有什么书会比此书讲的更明白。</p>

<h2>6.851 Advanced Data Structures</h2>

<p>Advanced Data Structures是MIT的高级数据结构教程，为什么会找到这个教程呢？因为Google Advanced Data Structures第一个出来的就是这货。</p>

<p>这门课包含各种让本屌世界观崩坏的奇诡数据结构和算法，它们包括但不限于：</p>

<ul>
<li>带”记忆”的数据结构（Data Structure with Persistence）。
van Emde Boas（逆天的插入，删除，前驱和后继时间复杂度）。
o(1)时间复杂度的的LCA、RMQ和LA解法。
奇幻的o(n)时间复杂度的Suffix Tree构建方法。
o(lglgn)的BST。
…</li>
</ul>

<p>总之高潮迭起，分分高能，唯一的不足就是没有把它们实现一圈。以后本屌一定找时间把它们一个个撸一遍。</p>

<h2>总结</h2>

<p>从接触算法到现在，大概七年：初学时推崇算法牛逼论，实习后鼓吹算法无用论，读研后再被现实打回算法牛逼论。</p>

<p>怎么这么像辩证法里的肯定到否定再到否定之否定。</p>

<p>现在来看，相当数量的鼓吹算法牛逼论的人其实不懂算法的重要性——如果你连用算法解决实际问题的经历都没有，那你如何可以证明算法很有用？而绝大多数鼓吹算法无用论的人不过是低水平码农的无病呻吟——他们从未碰到过需要用算法解决的难题，自然不知道算法有多重要。</p>

<p>Peter Norvig曾经写过一篇非常精彩的<a href="http://www.amazon.com/review/R403HR4VL71K8/">SICP书评</a>，我认为这里把SICP换成算法依然适用：
<blockquote>To use an analogy, if algorithms were about automobiles, it would be for the person who wants to know how cars work, how they are built, and how one might design fuel-efficient, safe, reliable vehicles for the 21st century. The people who hate algorithms are the ones who just want to know how to drive their car on the highway, just like everyone else.</blockquote></p>

<p>MIT教授<a href="http://erikdemaine.org/">Erik Demaine</a>则更为直接：
<blockquote>If you want to become a good programmer, you can spend 10 years programming, or spend 2 years programming and learning algorithms.</blockquote></p>

<p>总而言之，如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。</p>

<p>以上。</p>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[个人关注的博客与网站]]></title>
    <link href="http://huliuqing.github.io/most-visit-websites.html"/>
    <id>http://huliuqing.github.io/most-visit-websites.html</id>
    <updated>2014-05-06T09:00:00+08:00</updated>
    <content type="html"><![CDATA[<p>作为一名IT界菜鸟，我也有我心目中的“女神”。希望哪一天也能够向他们一样“受人敬仰”。如果你也喜欢我的“女神”们，请关注他们并点32个赞。</p>

<h2>PHP相关</h2>

<ul>
<li><p><a href="http://www.laruence.com/" target="_blank">风雪之隅</a></p></li>
<li><p><a href="http://www.php-internals.com/" target="_blank">@深入理解PHP内核</a>
<blockquote>TIPI是一个开源项目，这个项目是为了分享有关PHP内部实现的方方面面，以便更好地运用PHP。项目包含《深入理解PHP内核》这本开源书籍，同时还有其他相关的一些项目，比如一些PHP扩展</blockquote></p></li>
<li><p><a href="http://blog.csdn.net/heiyeshuwu" target="_blank">黑夜路人</a>
<blockquote>开源技术爱好者，CSDN博客技术专家。微信公众号：heiyeluren2012</blockquote></p></li>
<li><p><a href="http://www.phppan.com/" target="_blank">PHPpan</a>
<blockquote>深入理解PHP内核项目组成员之一</blockquote></p></li>
<li><p><a href="http://www.walu.cc/" target="_blank">walu</a></p></li>
<li><p><a href="http://www.wawacai.net/" target="_blank">第四部</a>
<blockquote>擅长：PHP/JavaScript/HTML(5)/CSS(3)</blockquote></p></li>
<li><p><a href="http://wulijun.github.io/php-the-right-way/" target="_blank">PHP之道</a>
<blockquote>Github上开源项目：网站的目标就是搜集PHP最佳实践、编码规范和网络上的权威学习指南，给PHP学习者提供一个易于阅读，快速查找的入口。</blockquote></p></li>
<li><p><a href="http://www.cnblogs.com/leoo2sk/" target="_blank">T2噬菌体</a> | <a href="http://blog.codinglabs.org/" target="_blank">CodingLabs</a>
<blockquote>码农一枚，山东人，目前混在北京。平时以写写代码、学学数学为乐。不写代码时喜欢踢足球、骑车、打游戏、看动漫和电影</blockquote></p></li>
<li><p><a href="http://www.cyrec.org/" target="_blank">Cyrec’s Blog </a></p></li>
<li><p><a href="http://www.mengjingde.com/" target="_blank">虎归山 = M.king</a>
<blockquote>M.king  另一个网名叫 虎归山 ，熟悉的网友更喜欢叫 虎子，一个北漂三年有余，一个互联网最普普通通的小伙</blockquote></p></li>
<li><p><a href="http://demon.at/" target="_blank">@DEMON</a>
<blockquote>主业打杂,副业php,linux c,标准矮穷挫。</blockquote></p></li>
</ul>

<h2>Web相关</h2>

<ul>
<li><p><a href="http://paranimage.com/" target="_blank">帕兰映像</a>
<blockquote>帕兰映像成立于2007年7月，主要关注科技网络、软件应用、设计开发和教程技巧等内容。</blockquote></p></li>
<li><p><a href="http://www.qianduan.net/" target="_blank">前端观察</a>
<blockquote>这里是一个纯粹的前端技术分享网站，本站的目的是为前端技术人员提供所需的资讯及资源。</blockquote></p></li>
<li><p><a href="http://www.w3cfuns.com" target="_blank">W3Cfuns</a></p></li>
<li><p><a href="http://www.csszengarden.com/" target="_blank">CSS 禅意花园</a></p></li>
<li><p><a href="http://www.smashingmagazine.com/" target="_blank">Smashing Magazine</a></p></li>
<li><p><a href="http://www.smashingmagazine.com/" target="_blank">AlloyTeam</a></p></li>
<li><p><a href="http://www.w3cplus.com/" target="_blank">W3Cplus</a>
<blockquote>记述前端那些事-引领web前沿-打造精品css3教程</blockquote></p></li>
<li><p><a href="http://www.w3cplus.com/" target="_blank">张鑫旭-鑫空间-鑫生活</a></p></li>
<li><p><a href="http://www.junchenwu.com/WAI/wai-pageauth.html" target="_blank">Web内容可访问性指南 1.0</a></p></li>
<li><p><a href="http://www.uisdc.com/" target="_blank">优设网</a>
<blockquote>记述前端那些事-引领web前沿-打造精品css3教程</blockquote></p></li>
<li><p><a href="http://www.colorhexa.com/" target="_blank">ColorHexa</a>
<blockquote>ColorHexa 是一个免费的颜色工具，提供与任何颜色相关的信息。只需在搜索框输入任意颜色值（查看完整列表），ColorHexa 就能给你返回一个详细的描述，并会自动将其转换成对应的十六进制、二进制、RGB、CMYK、HSL、HSV、 CIE-Lab、Hunter-Lab、CIE-Luv、CIE-LCH、XYZ、xyY 值。 </blockquote></p></li>
<li><p><a href="http://mrthink.net/" target="_blank">Mr.Think</a>
<blockquote>这里是我记录及分享知识与生活琐事的地方，文章均为原创，内容目前限于CSS技术、XHTML技术、JavaScript技术、SEO技术、UE知识</blockquote></p></li>
</ul>

<h2>数据库</h2>

<ul>
<li><p><a href="http://www.oicto.com/" target="_blank">赵荣涛</a>
<blockquote>这里是我记录及分享知识与生活琐事的地方，文章均为原创，内容目前限于CSS技术、XHTML技术、JavaScript技术、SEO技术、UE知识</blockquote></p></li>
<li><p><a href="http://dbanotes.net/" target="_blank">闲思录</a></p></li>
<li><p><a href="http://www.hellodb.net/" target="_blank">Hello Database</a>
<blockquote>张瑞，Oracle ACE，网名HelloDBA，2005年加入阿里巴巴DBA团队，擅长数据库性能优化与应用架构改进，历经阿里巴巴数据库技术的变革，现任职于阿里集团技术保障部DBA团队，负责淘宝和天猫的数据库支持工作</blockquote></p></li>
<li><p><a href="http://www.ningoo.net/" target="_blank">江边潮未尽，枫红一季秋</a></p></li>
</ul>

<h2>其它</h2>

<ul>
<li><p><a href="http://news.dbanotes.net/" target="_blank">Startup News</a></p></li>
<li><p><a href="http://huoding.com/" target="_blank">火丁笔记</a></p></li>
<li><p><a href="http://opencv.org/" target="_blank">OpenCV</a></p></li>
<li><p><a href="http://www.semyj.com/" target="_blank">SEM一家之言</a></p></li>
<li><p><a href="http://www.geek-cy.com/" target="_blank">geek-cy</a></p></li>
<li><p><a href="http://openresty.org/download/agentzh-nginx-tutorials-zhcn.html" target="_blank">agentzh 的 Nginx 教程</a></p></li>
</ul>

<p>以下列表本人很少涉及：</p>

<h2>数据结构与算法</h2>

<ul>
<li><p><a href="http://slowsnail.com.cn/" target="_blank">slow snail</a></p></li>
<li><p><a href="http://www.matrix67.com/blog/" target="_blank">Matrix67: The Aha Moments</a></p></li>
<li><p><a href="http://www.sorting-algorithms.com/" target="_blank">Sorting Algorithm Animations</a></p></li>
<li><p><a href="http://www.52nlp.cn/" target="_blank">我爱自然语言处理</a></p></li>
<li><p><a href="http://www.csie.ntnu.edu.tw/~u91029/" target="_blank">演算法筆記</a></p></li>
<li><p><a href="http://blog.52nlp.org/" target="_blank">52nlp's Learning Notes</a></p></li>
</ul>

<h2>安全</h2>

<ul>
<li><p><a href="http://evilcos.me/" target="_blank">EVILCOS @余弦</a></p></li>
<li><p><a href="http://web2hack.sinaapp.com/" target="_blank">《Web前端黑客技术揭秘》</a></p></li>
<li><p><a href="http://www.80sec.com/" target="_blank">80sec</a></p></li>
</ul>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[c++指针的指针]]></title>
    <link href="http://huliuqing.github.io/2014-04-30-cpp-pointers-to-pointers.html"/>
    <id>http://huliuqing.github.io/2014-04-30-cpp-pointers-to-pointers.html</id>
    <updated>2014-04-30T14:30:00+08:00</updated>
    <content type="html"><![CDATA[<p>本人最近在学习数据结构（大学没学），感觉在指针问题上需要进行更加深入的学习，才能更好的把数据结构学习和运用好。这篇文章是本人翻译的有关指针的文章(<a href="http://www.eskimo.com/~scs/cclass/int/sx8.html" title="Pointers to Pointers">Pointers to Pointers</a>)，供自己学习，有很多语法及表述不正确的地方，如果看到请指正或联系我： liuqing.phper.cn@gmail.com</p>

<p>自从我们可以使用整型指针，字符型指针，自定义结构类型的指针，又或者,我们可以使用任何C语言的任何类型的指针。于是我们可以使用指针指向另外一个指针也就理所当然的了。</p>

<p>如果我们曾经思考过关于指针的问题，那么去思考关于指针本身与之所指向的内容，或许更能够让我加深对指针的理解，也就是我所说的指针的指针。</p>

<p>虽然我们能够区分，指针所指向的内容，还是指针所指向的内容的指针（当然,我们也可以去理解指向指针的指针,指向指针的指针的指针,虽然这些没有太多实际用途）。</p>

<p>指针的指针定义如下：</p>

<pre><code>int **ipp;
</code></pre>

<p>两个星号表示指针的指针。首先让我们看一个简单的例子，来演示ipp指向通过声明定义的指针类型数据（int *ip1或 int * ip2），这些指针类型数据则指向整型变量(int i,j,k)</p>

<pre><code>int i = 5, j = 6; k = 7;
int *ip1 = &amp;i, *ip2 = &amp;j;
</code></pre>

<p>接下来对ipp赋值</p>

<pre><code>ipp = &amp;ip1;
</code></pre>

<p>ipp指向 ip1，ip1指向i,即**ipp就是i，i=5。我们可以使用下图表示 </p>

<p><img src="http://huliuqing.github.com/images/post-source/2014-04-30-cpp-point-to-point-1.gif" /></p>

<p>如果我们再次设置ipp如下：</p>

<pre><code>*ipp = ip2;
</code></pre>

<p>我们便改变了ipp变量所指向的指针地址为ip2.因而ipp（ip1）也就指向了j,如果我们赋值如下</p>

<p><img src="http://huliuqing.github.com/images/post-source/2014-04-30-cpp-point-to-point-2.gif" /></p>

<pre><code>*ipp = &amp;k;
</code></pre>

<p>我们便改变了ipp变量所指向的指针地址，为k的地址.因而ipp（ip1）也就指向了k</p>

<p><img src="http://huliuqing.github.com/images/post-source/2014-04-30-cpp-point-to-point-3.gif" /></p>

<p>在实际应用中，指针的指针应用在哪会比较合适呢？其中一个应用案例就是：通过把普通形参替换成指针做函数返回值。为了演示和说明，我们通过传入一个简单类型（如int型）的指针类型做函数的形参，函数如下：</p>

<pre><code>f(int *ip)
{
    *ip = 5;
}
</code></pre>

<p>然后调用</p>

<pre><code>int i;
f(&amp;i);
</code></pre>

<p>调用f函数之后将会“返回” 5给函数主调函数所传入的指针类型实参。</p>

<p>在这个示例中，主调函数为i变量。函数可以通过这种方法(传入指针类型变量)返回多个值。因为函数是只可以返回一个值。需要注意的是f函数是通过一个指针类型变量(int *)来返回值的。   </p>

<p>现在，如果我们需要函数返回一个指针，传入的形参类型需要为指针的指针。在这有一个函数为长度为n的字符分配内存，失败返回0、成功返回1，并且返回指针指向新分配内存的指针</p>

<pre><code>#include &lt;stdlib.h&gt;

int allocstr(int len, char **retptr)
{
    char *p = malloc(len + 1);  /* +1 for \0 */
    if(p == NULL)
        return 0;
    *retptr = p;
    return 1;
}

//主调函数如下
char *string = "Hello, world!";
char *copystr;
if(allocstr(strlen(string), &amp;copystr))
    strcpy(copystr, string);
else
    fprintf(stderr, "out of memory\n");
</code></pre>

<p>（allocstr函数并非特别实用，仅仅是个简单的内存分配函数示例，为了易于调用并直接分配内存空间。我们使用的chkmalloc函数将更加实用）</p>

<pre><code>double *dptr;
if(!hypotheticalwrapperfunc(100, sizeof(double), &amp;dptr))
    fprintf(stderr, "out of memory\n");
</code></pre>

<p>hypotheticalwrapperfunc不允许传入void <strong>类型参数，而是需要传入double</strong>类型参数
对于指针的指针，同样适用于模拟实现多维数组的动态内存分配，这将在下一章节讨论。</p>

<p>最后一个示例，让我们看看指针的指针是如何用来解决链表中插入和删除这个令人讨厌的问题的。简单起见，我们仅仅考虑整型链表，结构体如下：</p>

<p>struct list
    {
        int item;
        struct list *next;
    };</p>

<p>让我们尝试从链表中删除给定的整数。简单的解决方案如下：    </p>

<pre><code>/* delete node containing i from list pointed to by lp */

struct list *lp, *prevlp;
for(lp = list; lp != NULL; lp = lp-&gt;next)
{
    if(lp-&gt;item == i)
    {
        if(lp == list)
        {
            list = lp-&gt;next;
        }else
        {
            prevlp-&gt;next = lp-&gt;next;
            break;
        }
        prevlp = lp;
    }
}
</code></pre>

<p>这段代码是可以运行的，但是存在两个不足之处。
    第一、我们需要使用一个额外的变量来保存节点与节点的关系。
    第二、当节点在链表头部被删除，我们需要使用额外的测试。为什么会出现这两个不足，原因在于我们从链表中删除一个节点，会涉及到指针所指向的节点需要移动到下一个节点（删除节点的前一节点的指针，需要指向删除节点的下一节点）。但这取决于删除节点是不是头一个节点，如果是头一个节点我们需要时指针指向链表的新头部，如果不是我们需要将删除节点的前一个节点的指针指向下一个节点。</p>

<p>为了阐明这一点，加点我们有一个链表 list(1,2,3)。让我们从表中删除节点1。当我们找到1节点时，指针变量lp指向节点1，而链表list的指针其实也是指向同一个节点1的，如下图（a）所示：</p>

<p><img src="http://huliuqing.github.com/images/post-source/2014-04-30-cpp-point-to-point-4.gif" /></p>

<p>删除节点1之后，我们需要使链表list的指针指向链表的第二个节点，也就是链表新的头结点（图（b）所示）。</p>

<p>假使我们需要删除的是元素的节点2（如图（c）所示）。</p>

<p>我们则需要让链表的第一个节点的指针指向节点3。</p>

<p>指针变量prevlp要保存前一个节点，因为我们需要让它的下一个节点做出调整（另外我们要注意的是如果我们要删除第三个节点，我们要把它所指向下一个节点地址，复制给节点2，但节点3的下一个节点地址为空，所以此时节点2就是链表新的尾节点）。</p>

<p>让我们再来重写链表的删除操作，通过运用链表指针的指针，新的实现方法更加简单。这个指针将指向我们所查找节点的指针，它既可以指向头指针也可以指向下一个节点指针。直到这个指针所指向的指针，是指向我们需要查找的节点时为止，它指向我们查找并需要修改删除的节点指针。让我们来看看代码。</p>

<p>struct list **lpp;
    for(lpp = &list; <em>lpp != NULL; lpp = &amp;(</em>lpp)->next)
    {
        if( (<em>lpp)->item == i)
        {
            *lpp = (</em>lpp)->next;
            break;<br />
        }
    }</p>

<p>代码 <em>lpp = (</em>lpp)->next会更新当前的指针，不论是头指针还是其中的任何一个指针（当然初见之下，在链表上运用指针的指针，所采用的算法并不会带来多大的好处）。为了简单阐述指针的指针在lpp变量上的操作，通过两张图来演示删除第一个节点（左图）和第二个节点（右图）。</p>

<p><img src="http://huliuqing.github.com/images/post-source/2014-04-30-cpp-point-to-point-5.gif" /></p>

<p>在以上两个链表删除操作的示例中</p>

<pre><code>① lpp变量所指向的是，一个指向被删除节点的节点指针。
② lpp所指向的指针，是将被更新的指针。
③ 新的指针（*lpp更新的指针）是被删除节点的下一个指针，它永远是(*lpp)-&gt;next
</code></pre>

<p>*lpp所指向的下一个节点指针，也就是lpp所指向的指针的指针。可以替换如下： </p>

<p>lpp = &amp;(*lpp)->next</p>

<p>通过<em>lpp,将lpp指向list链表的下一个域。不管怎样括号都不能省略，因为->优先级高于</em>的优先级。</p>

<p>接下来让我们看一个相关的示例，让我们在list链表中插入一个新的节点。同样适用list链表结构的指针的指针，这样，我们就不用来区别对待list链表在不同情况下的插入了。</p>

<p>/* insert node newlp into list */</p>

<pre><code>struct list **lpp;
for(lpp = &amp;list; *lpp != NULL; lpp = &amp;(*lpp)-&gt;next)
{
    struct list *lp = *lpp;
    if(newlp-&gt;item &lt; lp-&gt;item)
    {
        newlp-&gt;next = lp;
        *lpp = newlp;
        break;
    }
}
</code></pre>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[个人书单]]></title>
    <link href="http://huliuqing.github.io/book-lists.html"/>
    <id>http://huliuqing.github.io/book-lists.html</id>
    <updated>2014-04-28T17:13:00+08:00</updated>
    <content type="html"><![CDATA[<p>过去三年，在位于江西南昌的一家初创公司从事PHP相关开发工作，且行且努力。以下列出个人这三年阅读的图书</p>

<h2>目标</h2>

<p>领域内深入 、 领域外涉猎</p>

<h2>编程语言</h2>

<ul>
<li><p>《java核心技术（卷一、卷二）》 --2011年8-10月份</p></li>
<li><p>《c++探秘：68讲贯通C++》--2012年1-2月份</p></li>
<li><p>《PHP和MySql web开发》  --2012年4-5月份</p></li>
<li><p>《高性能php应用开发》   --2012年10-11月份</p></li>
<li><p>《PHP调试技术手册》     --2013年7月份</p></li>
</ul>

<h2>前端 css</h2>

<ul>
<li><p>《CSS禅意花园》  --2013年2-3月份</p></li>
<li><p>《CSS实战手册》  --2013年5-6月份</p></li>
</ul>

<h2>前端 javascript</h2>

<ul>
<li><p>《javascript DOM编程艺术》 --2013年7月份</p></li>
<li><p>《Node.js 入门指南》       --2013年8月份</p></li>
</ul>

<h2>数据库</h2>

<ul>
<li><p>《Oracle 10g宝典》 --2011年11-12月份</p></li>
<li><p>《SQLCOOKBOK》</p></li>
</ul>

<h2>阅读手册</h2>

<ul>
<li>php手册  http://php.net  --2012年3月至今</li>
</ul>

<h2>正在阅读</h2>

<ul>
<li><p>《php高级程序设计 -模式、框架与调试》</p></li>
<li><p>《MySQL技术内幕InnoDB存储引擎》</p></li>
<li><p>《无懈可击的web项目》</p></li>
<li><p>《面向对象分析与设计（第三版）》</p></li>
</ul>

<h2>想要阅读</h2>

<ul>
<li><p>《大话设计模式》</p></li>
<li><p>《大话数据结构》</p></li>
<li><p>《章亦春nginx漫谈》</p></li>
<li><p>《apache手册》</p></li>
<li><p>《apache手册》</p></li>
</ul>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[个人技能一览]]></title>
    <link href="http://huliuqing.github.io/web-skills-me.html"/>
    <id>http://huliuqing.github.io/web-skills-me.html</id>
    <updated>2014-04-25T16:48:00+08:00</updated>
    <content type="html"><![CDATA[<script type="text/javascript" src="http://visjs.org/dist/vis.js"></script>

<p>在这边梳理一下个人所学习过，并且一直在学习的专业技能，当然还有很多没有学习到的内容。
但在此还是写梳理出掌握的比较好。也算是对自己这3年来的一个交代吧</p>

<div id="skills"></div>

<script type="text/javascript">
  // create an array with nodes
  var nodes = [
    {id: 1, label: '已掌握Web开发技能',color:'rgb(61,89,159)',fontColor:'#fff'},
    {id: 2, label: '客户端编程'},
    {id: 3, label: '服务器端编程'},
    {id: 4, label: '数据库存储'},
    {id: 5, label: 'html',color:'rgb(61,89,159)',fontColor:'#fff'},
    {id: 6, label: 'css',color:'rgb(61,89,159)',fontColor:'#fff'},
    {id: 7, label: 'javascript',color:'rgb(61,89,159)',fontColor:'#fff'},
    {id: 8, label: '历史标准语规范'},
    {id: 9, label: '常用标签与属性'},
    {id: 10, label: 'DOM / BOM'},
    {id: 11, label: '语法、继承规则'},
    {id: 12, label: '选择器与常用属性'},
    {id: 13, label: '基本布局与定位知识'},
    {id: 14, label: 'css禅意花园与css实战手册'},
    {id: 15, label: 'ajax基础知识'},
    {id: 16, label: 'jquery基础知识'},
    {id: 17, label: 'javascript  javascript DOM 编程艺术(2th)'},
    {id: 18, label: '前端基础优化知识'},
    {id: 19, label: 'PHP',color:'rgb(61,89,159)',fontColor:'#fff'},
    {id: 20, label: 'HTTP',color:'rgb(61,89,159)',fontColor:'#fff'},
    {id: 21, label: '知识方法与可读性',color:'rgb(61,89,159)',fontColor:'#fff'},
    {id: 22, label: 'php语言 、手册核心内容阅读完'},
    {id: 23, label: '源码阅读Zend1.0/Typecho/ucenter'},
    {id: 24, label: '框架Zend/smarty'},
    {id: 30, label: 'php运行时配置与性能优化'},
    {id: 31, label: 'php生命周期与变量等内核实现'},
    {id: 25, label: 'http基础知识'},
    {id: 26, label: '代码可读性'},
    {id: 27, label: 'web基础安全知识与SQL注入'},
    {id: 28, label: '设计模式 学习中'},
    {id: 29, label: '基础缓存策略与php调试技术手册'},
    {id: 32, label: 'mysql数据库',color:'rgb(61,89,159)',fontColor:'#fff'},
    {id: 33, label: 'DML/DQL/DDL'},
    {id: 34, label: '数据类型/函数'},
    {id: 35, label: '事务、存储过程、视图基础知识'},
    {id: 36, label: '基础sql优化策略'},
  ];

  // create an array with edges
  var edges = [
    {from: 1, to: 2,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 1, to: 3,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 1, to: 4,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 2, to: 5,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 2, to: 6,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 2, to: 7,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 5, to: 8,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 5, to: 9,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 5, to: 10,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 6, to: 11,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 6, to: 12,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 6, to: 13,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 6, to: 14,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 7, to: 15,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 7, to: 16,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 7, to: 17,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 7, to: 18,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 3, to: 19,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 3, to: 20,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 3, to: 21,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 19, to: 22,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 19, to: 23,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 19, to: 24,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 19, to: 30,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 19, to: 31,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 20, to: 25,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 21, to: 26,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 21, to: 27,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 21, to: 28,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 21, to: 29,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 4, to: 32,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 32, to: 33,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 32, to: 34,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 32, to: 35,style: 'dash-line', dash: {length: 5, gap: 5}},
    {from: 32, to: 36,style: 'dash-line', dash: {length: 5, gap: 5}}
  ];

  // create a graph
  var container = document.getElementById('skills');
  var data= {
    nodes: nodes,
    edges: edges
  };
  var options = {
    nodes: {
      shape: 'box'
    },
    edges: {
      length: 700
    },
    width:'800px',
    height:'800px'
  };
  var graph = new vis.Graph(container, data, options);
</script>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[PMBlog links 和menus使用介绍]]></title>
    <link href="http://huliuqing.github.io/introduce-pmblog-lins-menus.html"/>
    <id>http://huliuqing.github.io/introduce-pmblog-lins-menus.html</id>
    <updated>2014-04-24T14:13:34+08:00</updated>
    <content type="html"><![CDATA[<p>最近我一直有在积累的博客，被关闭了。现在才体会到为什么不能够寄住在别人的博客平台，记录和分享工作中的点滴。</p>

<p>在这里我想对51CTO的全体工作人员说一句'cao 草'，能不能联系你们并回复下我。</p>

<p>没办法想到了在github可以开通自己的blog，尝试了一下。不过在使用jekyll的时候环境一直无法搭建，感谢公司</p>

<p>万幸在强大的github上，找到了PMBlog，谢谢<a href="https://github.com/lizheming">公子</a>（类似jekyll）。现在介绍关于PMBlog程序中links和menus插件的相关使用方法</p>

<h2>PMBlog的links链接和menus导航基本介绍</h2>

<p>通过如下地址下载需要的插件<a href="https://github.com/lizheming/PMBlog/wiki/%E6%8F%92%E4%BB%B6">PMBlog 插件</a></p>

<p>这里我下载的是 Page2Link 和 Page2Menu插件，并放置到usr/plugin目录下</p>

<p>Page2Link插件</p>

<blockquote>友情链接插件，按照links.example.html的格式（其实就是Markdown的链接格式）将链接一行一个写好，保存成links.html。主题模板中可以使用{{link}}变量调用它。{{link}}变量是一个数组变量，需要使用循环才能输出</blockquote>

<p>Page2Menu插件</p>

<blockquote>导航链接插件，按照menus.example.html的格式（其实就是Markdown的链接格式）将链接一行一个写好，保存成menus.html。主题模板中可以使用{{menus}}变量调用它。{{menus}}变量是一个数组变量，需要使用循环才能输出</blockquote>

<h2>插件使用</h2>

<p>关于这两个的插件使用也是非常的简单的，我们只需要</p>

<pre><code># 配置config.php文件
$config['actived_plugins'] ="Page2Links,Page2Menus" //我们也可以简单的使用*开启全部的插件
# 使用
在模板文件中，我们仅仅需要添加如下代码便可以完成，link/menu的功能
{% for item in menu/link %}
    {{item.title}}  {# MenuItem's title #}
    {{item.url}}    {# MenuItem's url #}
    {{item.description}}    {# MenuItem's description #}
 {% endfor %}
</code></pre>
]]></content>
  </entry>
    <entry>
    <title type="html"><![CDATA[关于我 / About Me]]></title>
    <link href="http://huliuqing.github.io/aboutme.html"/>
    <id>http://huliuqing.github.io/aboutme.html</id>
    <updated>2014-04-22T16:25:02+08:00</updated>
    <content type="html"><![CDATA[<p>柳公子</p>

<h2>出生&求学</h2>

<p>我出生在江西九江的一个农村。
12岁以前过着无忧无虑的生活：春天放牛、夏天钓虾，冬天烤炭火。
12-23岁开始一个人的求学路，借读初中、高中，再然后于江西南昌读大学</p>

<h2>教育</h2>

<p>2007年9月入学江西南昌大学软件学院，软件技术专业。开始程序开发之路</p>

<h2>经历</h2>

<p>关于我的经历，2008年之后才慢慢开始精彩起来</p>

<ul>
<li>2008年入伍</li>
<li>2010年退役</li>
<li>2011年续学</li>
<li>2011年底进入江西腾王科技开发游戏。结果进入web开发领域，从事PHP开发相关工作至今</li>
</ul>

<h2>联系我</h2>

<p>可以通过以下方式联系到我：</p>

<ul>
<li>gmail:huliuqing1989@gmail.com</li>
<li>weibo:http://weibo.com/focusliuqing</li>
</ul>

<h2>关注我</h2>

<p>作为伪技术型宅男，偶尔会出现在这些地方。</p>

<ul>
<li>stackoverflow : http://stackoverflow.com/users/1969039/liuqing-hu</li>
<li>github : https://github.com/huliuqing</li>
</ul>

<h2>目标</h2>

<p>为成为正真的技术型宅男而努力奋斗</p>
]]></content>
  </entry>
  </feed>